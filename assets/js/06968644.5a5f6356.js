"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[22784],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},c=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=d(a),m=i,p=u["".concat(l,".").concat(m)]||u[m]||h[m]||o;return a?n.createElement(p,s(s({ref:t},c),{},{components:a})):n.createElement(p,s({ref:t},c))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,s=new Array(o);s[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var d=2;d<o;d++)s[d]=a[d];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},59679:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var n=a(87462),i=(a(67294),a(3905));const o={},s="NoSQL Data Modeling",r={unversionedId:"data-modeling/nosql-data-modeling",id:"data-modeling/nosql-data-modeling",title:"NoSQL Data Modeling",description:"What is a NoSQL data model?",source:"@site/docs/04-data-modeling/nosql-data-modeling.md",sourceDirName:"04-data-modeling",slug:"/data-modeling/nosql-data-modeling",permalink:"/docs/data-modeling/nosql-data-modeling",draft:!1,tags:[],version:"current",lastUpdatedBy:"sparsh",lastUpdatedAt:1681047270,formattedLastUpdatedAt:"Apr 9, 2023",frontMatter:{},sidebar:"docs",previous:{title:"Lab: AirBnB Postgres Datamodel",permalink:"/docs/data-modeling/lab-airbnb-postgres-datamodel/"},next:{title:"Data Extraction from APIs",permalink:"/docs/extraction/api/"}},l={},d=[{value:"What is a NoSQL data model?",id:"what-is-a-nosql-data-model",level:2},{value:"How is data stored in NoSQL?",id:"how-is-data-stored-in-nosql",level:2},{value:"Does NoSQL have a schema?",id:"does-nosql-have-a-schema",level:2},{value:"What data model does NoSQL use?",id:"what-data-model-does-nosql-use",level:2},{value:"NoSQL Data Modeling Techniques",id:"nosql-data-modeling-techniques",level:2},{value:"Conceptual Techniques",id:"conceptual-techniques",level:3},{value:"General Modeling Techniques",id:"general-modeling-techniques",level:3},{value:"Hierarchy Modeling Techniques",id:"hierarchy-modeling-techniques",level:3}],c={toc:d};function h(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"nosql-data-modeling"},"NoSQL Data Modeling"),(0,i.kt)("h2",{id:"what-is-a-nosql-data-model"},"What is a NoSQL data model?"),(0,i.kt)("p",null,"It\u2019s a model that is not reinforced by a Relational Database Management System (RDBMS). Therefore, the model isn\u2019t explicit about how the data relates \u2013 how it all connects together."),(0,i.kt)("p",null,"The primary difference is that NoSQL does not use a relational data modeling technique and it emphasizes flexible design. The lack of requirement for a schema makes designing a much simpler and cheaper process. That isn\u2019t to say that you can\u2019t use a schema altogether, but rather that schema design is very flexible."),(0,i.kt)("p",null,"Another useful feature of NoSQL data models is that they are built for high efficiency and speed in terms of creating up to millions of queries a second. This is achieved through having all the data contained within one table, and so JOINS and cross-referencing is not as performance heavy. "),(0,i.kt)("p",null,"NoSQL is also unique in that it is horizontally scalable, compared to SQL which is only vertically scalable. With NoSQL you can simply use another shard, which is cheap, rather than buying more hardware, which is not."),(0,i.kt)("h2",{id:"how-is-data-stored-in-nosql"},"How is data stored in NoSQL?"),(0,i.kt)("p",null,"In one of the main non-relational database models, such as a key-value store, document store, graph data model, time series store, column-oriented. Data can be stored on disk, in-memory, or both."),(0,i.kt)("h2",{id:"does-nosql-have-a-schema"},"Does NoSQL have a schema?"),(0,i.kt)("p",null,"Yes, it does. When people say NoSQL is \u201cschemaless,\u201d they really mean the schema is flexible and determined by the developer and application needs over time. . A schema is eventually settled upon \u2013 it doesn\u2019t exist at the onset, as is the case with a SQL database."),(0,i.kt)("p",null,"Since NoSQL databases don\u2019t really have a set structure, development and schema design tends to be focused around the physical data model. That means developing for large, horizontally expansive environments, something that NoSQL excels at. Therefore, the specific quirks and problems that come with scalability are at the forefront."),(0,i.kt)("p",null,"As such, the first step is to define business requirements, as optimizing data access is a must, and can only be achieved by knowing what the business wants to do with the data. Your schema design should complement the workflows tied to your use case."),(0,i.kt)("p",null,"There are several ways to select the primary key, and ultimately that depends on the users themselves. That being said, some data might suggest a more efficient schema, especially in terms of how often that data is queried. "),(0,i.kt)("h2",{id:"what-data-model-does-nosql-use"},"What data model does NoSQL use?"),(0,i.kt)("p",null,"NoSQL databases fall into four main categories or types. One thing they have in common is that they do not use the rigid tabular row-and-column data model that traditional relational databases (sometimes called SQL databases) use."),(0,i.kt)("p",null,"Instead, NoSQL databases have a data model that reflects their particular category. Document databases can store a great deal of information in a single document and can nest documents. Key-value stores have a simple data model, just as their name implies. Wide column stores feature more variation in data types and the number of columns in use than row-oriented relational databases. Graph databases have data models based on graph theory, with data models made up of nodes and edges that relate those nodes."),(0,i.kt)("h2",{id:"nosql-data-modeling-techniques"},"NoSQL Data Modeling Techniques"),(0,i.kt)("p",null,"All NoSQL data modeling techniques are grouped into three major groups:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Conceptual techniques")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"General modeling techniques")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Hierarchy modeling techniques"))),(0,i.kt)("p",null,"Below, we will briefly discuss all NoSQL data modeling techniques."),(0,i.kt)("h3",{id:"conceptual-techniques"},"Conceptual Techniques"),(0,i.kt)("p",null,"There are a three conceptual techniques for NoSQL data modeling:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Denormalization"),". Denormalization is a pretty common technique and entails copying the data into multiple tables or forms in order to simplify them. With denormalization, easily group all the data that needs to be queried in one place. Of course, this does mean that data volume does increase for different parameters, which increases the data volume considerably."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Aggregates"),". This allows users to form nested entities with complex internal structures, as well as vary their particular structure. Ultimately, aggregation reduces joins by minimizing one-to-one relationships.",(0,i.kt)("br",{parentName:"li"}),"Most NoSQL data models have some form of this soft schema technique. For example, graph and key-value store databases have values that can be of any format, since those data models do not place constraints on value. Similarly, another example such as BigTable has aggregation through columns and column families."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Application Side Joins.")," NoSQL doesn\u2019t usually support joins, since NoSQL databases are question-oriented where joins are done during design time. This is compared to relational databases where are performed at query execution time. Of course, this tends to result in a performance penalty and is sometimes unavoidable.")),(0,i.kt)("h3",{id:"general-modeling-techniques"},"General Modeling Techniques"),(0,i.kt)("p",null,"There are a five general techniques for NoSQL data modeling:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Enumerable Keys"),". For the most part, unordered key values are very useful, since entries can be partitioned over several dedicated servers by just hashing the key. Even so, adding some form of sorting functionality through ordered keys is useful, even though it may add a bit more complexity and a performance hit."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Dimensionality Reduction"),". Geographic information systems tend to use ",(0,i.kt)("strong",{parentName:"li"},"R-Tree")," indexes and need to be updated in-place, which can be expensive if dealing with large data volumes. Another traditional approach is to flatten the 2D structure into a plain list, such as what is done with Geohash.",(0,i.kt)("br",{parentName:"li"}),"With dimensionality reduction, you can map multidimensional data to a simple key-value or even non-multidimensional models.",(0,i.kt)("br",{parentName:"li"}),"Use dimensionality reduction to map multidimensional data to a Key-Value model or to another non-multidimensional model."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Index Table.")," With an index table, take advantage of indexes in stores that don\u2019t necessarily support them internally. Aim to create and then maintain a unique table with keys that follow a specific access pattern. For example, a master table to store user accounts for access by user ID."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Composite Key Index"),". While somewhat of a generic technique, composite keys are incredibly useful when ordered keys are used. If you take it and combine it with secondary keys, you can create a multidimensional index that is pretty similar to the above-mentioned Dimensionality Reduction technique."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Inverted Search \u2013 Direct Aggregation.")," The concept behind this technique is to use an index that meets a specific set of criteria, but then aggregate that data with full scans or some form of original representation.",(0,i.kt)("br",{parentName:"li"}),"This is more of a data processing pattern than data modeling, yet data models are certainly affected by using this type of processing pattern. Take into account that random retrieval of records required for this technique is inefficient. Use query processing in batches to mitigate this problem.")),(0,i.kt)("h3",{id:"hierarchy-modeling-techniques"},"Hierarchy Modeling Techniques"),(0,i.kt)("p",null,"There are a seven hierarchy modeling techniques for NoSQL data:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Tree Aggregation.")," Tree aggregation is essentially modeling data as a single document. This can be really efficient when it comes to any record that is always accessed at once, such as a Twitter thread or Reddit post. Of course, the problem then becomes that random access to any individual entry is inefficient."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Adjacency Lists.")," This is a straightforward technique where nodes are modeled as independent records of arrays with direct ancestors. That\u2019s a complicated way of saying that it allows you to search nodes by their parents or children. Much like tree aggregation though, it is also quite inefficient for retrieving an entire subtree for any given node."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Materialized Paths.")," This technique is a sort of denormalization and is used to avoid recursive traversals in tree structures. Mainly, we want to attribute the parents or children to each node, which helps us determine any predecessors or descendants of the node without worrying about traversal. Incidentally, we can store materialized paths as IDs, either as a set or a single string."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Nested Sets"),". A standard technique for tree-like structures in relational databases, it\u2019s just as applicable to NoSQL and key-value or document databases. The goal is to store the tree leaves as an array and then map each non-leaf node to a range of leaves using start/end indexes.",(0,i.kt)("br",{parentName:"li"}),"Modeling it in this way is an efficient way to deal with immutable data as it only requires a small amount of memory, and doesn\u2019t necessarily have to use traversals. That being said, updates are expensive because they require updates of indexes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Nested Documents Flattening: Numbered Field Names.")," Most search engines tend to work with documents that are a flat list of fields and values, rather than something with a complex internal structure. As such, this data modeling technique tries to map these complex structures to a plain document, for example, mapping documents with a hierarchical structure, a common difficulty you might encounter.",(0,i.kt)("br",{parentName:"li"}),"Of course, this type of work is pain-staking and not easily scalable, especially as the nested structures increase."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Nested Documents Flattening: Proximity Queries.")," One way to solve the potential problems with the Numbered Field Names data modeling technique is to use a similar technique called ",(0,i.kt)("strong",{parentName:"li"},"Proximity Queries."),"\xa0These limit the distance between words in a document, which helps increase performance and decrease query speed impact."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Batch Graph Processing.")," Batch graph processing is a great technique for exploring the relationships up or down for a node, within a few steps. It is an expensive process and doesn\u2019t necessarily scale very well. By using Message Passing and MapReduce we can carry out this type of graph processing.")))}h.isMDXComponent=!0}}]);
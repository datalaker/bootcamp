"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[57191],{3905:(e,t,a)=>{a.d(t,{Zo:()=>s,kt:()=>m});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var d=n.createContext({}),p=function(e){var t=n.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},s=function(e){var t=p(e.components);return n.createElement(d.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,d=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),h=p(a),m=r,c=h["".concat(d,".").concat(m)]||h[m]||u[m]||i;return a?n.createElement(c,l(l({ref:t},s),{},{components:a})):n.createElement(c,l({ref:t},s))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=h;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},6602:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var n=a(87462),r=(a(67294),a(3905));const i={},l="Housing Data Model with CDC and SCD Type 2",o={unversionedId:"data-modeling/lab-postgres-housing-cdc-scd/README",id:"data-modeling/lab-postgres-housing-cdc-scd/README",title:"Housing Data Model with CDC and SCD Type 2",description:"A critical aspect of data engineering is dealing with data change from one date to the next. In this case, we want both the current and historical value. There are many techniques and patterns to create a historical-friendly model during the ingestion and modeling phases. In this lab, we will build a data model that uses Change Data Capture and Slowly Changing Dimension Type 2 modelization to track housing prices. The code is written in Python.\xa0pandas\xa0and\xa0sqlalchemy\xa0library is used to load data from CSV files and execute SQL queries against the data warehouse.",source:"@site/docs/04-data-modeling/lab-postgres-housing-cdc-scd/README.md",sourceDirName:"04-data-modeling/lab-postgres-housing-cdc-scd",slug:"/data-modeling/lab-postgres-housing-cdc-scd/",permalink:"/docs/data-modeling/lab-postgres-housing-cdc-scd/",draft:!1,tags:[],version:"current",lastUpdatedBy:"sparsh",lastUpdatedAt:1681047270,formattedLastUpdatedAt:"Apr 9, 2023",frontMatter:{}},d={},p=[{value:"Data ingestion",id:"data-ingestion",level:2},{value:"Data Modeling",id:"data-modeling",level:2},{value:"Backfill and Recompute Data",id:"backfill-and-recompute-data",level:2},{value:"Conclusion",id:"conclusion",level:2}],s={toc:p};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"housing-data-model-with-cdc-and-scd-type-2"},"Housing Data Model with CDC and SCD Type 2"),(0,r.kt)("p",null,"A critical aspect of data engineering is dealing with data change from one date to the next. In this case, we want both the current and historical value. There are many techniques and patterns to create a historical-friendly model during the ingestion and modeling phases. In this lab, we will build a data model that uses Change Data Capture and Slowly Changing Dimension Type 2 modelization to track housing prices. The code is written in Python.\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"pandas"),"\xa0and\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"sqlalchemy"),"\xa0library is used to load data from CSV files and execute SQL queries against the data warehouse."),(0,r.kt)("p",null,"The model will answer three following questions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"How many offers are currently available?"),(0,r.kt)("li",{parentName:"ul"},"The average price."),(0,r.kt)("li",{parentName:"ul"},"The average cost per m2.")),(0,r.kt)("p",null,"Each KPI will be analyzed by the time dimension. The time dimension will be granular by day. In addition, we will consider two other factors: the type of accommodation (apartment or house) and whether or not the house already has furniture. You can change these configurations according to your needs."),(0,r.kt)("p",null,"To know the average price of all available offers on any day, we need to analyze not only the offers published on that day but also those that were published before and are still active. In addition, a price of an offer may change over time. This obliges us to detect changes in data and store all historical versions in the database. For example, if a property cost ",(0,r.kt)("inlineCode",{parentName:"p"},"500$")," yesterday but only ",(0,r.kt)("inlineCode",{parentName:"p"},"480$")," today. The value used to compute the average price for yesterday should be ",(0,r.kt)("inlineCode",{parentName:"p"},"500$"),". But to run the same calculation for today, we should use ",(0,r.kt)("inlineCode",{parentName:"p"},"480$")," instead."),(0,r.kt)("p",null,"Change Data Capture refers to the technique we used to detect changes in the data source. Slowly Changing Dimension is the way we structure and store data to keep both historical and current data in the data warehouse."),(0,r.kt)("h2",{id:"data-ingestion"},"Data ingestion"),(0,r.kt)("p",null,"After collecting data from the website, we'll load the new data to the data warehouse. Suppose we already have some data in the warehouse, we won't need the same data again. Otherwise, the statistics won't be correct. Here is what we need to implement:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add new data to the warehouse"),(0,r.kt)("li",{parentName:"ul"},"For data that has been changed on the website (for example, the price drops), we'll mark them as expired and add the new version to the warehouse."),(0,r.kt)("li",{parentName:"ul"},'If the offer is no longer available on the website, we mark it as "expired" in the warehouse.')),(0,r.kt)("p",null,'To determine whether a property is "new", we can use the technique described\xa0',(0,r.kt)("a",{parentName:"p",href:"https://www.sspaeti.com/blog/data-engineering-project-in-twenty-minutes"},"here"),". We'll add a new field called\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"fingerprint"),'\xa0that will be used to differentiate properties. We already have the "prop_id" field, which is a unique identifier, in the data source. Since we also want to track the price, we will add that information to the\xa0',(0,r.kt)("inlineCode",{parentName:"p"},"fingerprint"),". As a result, the fingerprint is created by joining\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"prop_id"),"\xa0and\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"price"),". We can have many rows for the same property in the database, as long as the price is different."),(0,r.kt)("p",null,"We create a table called\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"housing_staging"),"\xa0for pre-aggregation data and\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"housing_model"),"\xa0for aggregated data. In the staging table, we use\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"valid_from"),"\xa0and\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"expired"),"\xa0fields to track the offer. We will see how these fields are used in the BackFill and Recompute Data part."),(0,r.kt)("p",null,"Now suppose you loaded the data collected to a table\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"tmp_housing"),". Thanks to the field\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"fingerprint"),"\xa0, we can identify offers that have been changed or removed from the website."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT h.id\nFROM housing_staging h\nLEFT JOIN tmp_housing t\nON h.prop_id = t.prop_id\nAND h.expired IS NULL\nWHERE t.prop_id IS NULL\nOR h.fingerprint != t.fingerprint\n")),(0,r.kt)("p",null,"We update those lines in the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"housing_staging"),"\xa0table by setting the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"expired"),"\xa0value to the previous day (recall that we're using day-granularity)."),(0,r.kt)("p",null,"Symmetrically, we can use the query below to find the new-or-updated offers:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT t.id\nFROM tmp_housing t\nLEFT JOIN housing_staging h\nON h.prop_id = t.prop_id\nAND h.expired IS NULL\nWHERE h.prop_id IS NULL\nOR h.fingerprint != t.fingerprint\n")),(0,r.kt)("p",null,"We add new-or-updated data in the warehouse. The\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"valid_from"),"\xa0field is set to the beginning of the date for the same reason as the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"expired"),"\xa0field above."),(0,r.kt)("h2",{id:"data-modeling"},"Data Modeling"),(0,r.kt)("p",null,"We can compute the 3 KPIs mentioned in the Introduction section from the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"housing_staging"),"\xa0table. The idea is to filter out expired data."),(0,r.kt)("h2",{id:"backfill-and-recompute-data"},"Backfill and Recompute Data"),(0,r.kt)("p",null,"Sometimes, we need to backfill and recompute data for a day in the past. For instance, when you discover corrupted data in the warehouse and decide to reload the staging data and recalculate the KPI. Another example is that our pipeline failed to load data to the warehouse due to an error."),(0,r.kt)("p",null,"The tricky part is when we reload data for a day, the data of later dates will be affected. To illustrate that, consider this scenario:"),(0,r.kt)("p",null,"We have the following rows in the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"housing_staging"),"\xa0table:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"prop_id"),(0,r.kt)("th",{parentName:"tr",align:null},"valid_from"),(0,r.kt)("th",{parentName:"tr",align:null},"expired"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-02-18 00:00:00"),(0,r.kt)("td",{parentName:"tr",align:null},"NULL")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-02-18 00:00:00"),(0,r.kt)("td",{parentName:"tr",align:null},"NULL")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"8"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-02-18 00:00:00"),(0,r.kt)("td",{parentName:"tr",align:null},"NULL")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"9"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-02-18 00:00:00"),(0,r.kt)("td",{parentName:"tr",align:null},"NULL")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"10"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-02-18 00:00:00"),(0,r.kt)("td",{parentName:"tr",align:null},"NULL")))),(0,r.kt)("p",null,"Now if we want to load data in the file\xa002_01_2023.csv,\xa0we should have this result:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"prop_id"),(0,r.kt)("th",{parentName:"tr",align:null},"valid_from"),(0,r.kt)("th",{parentName:"tr",align:null},"expired"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-01-02 00:00:00"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-02-17 23:59:59")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-01-02 00:00:00"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-02-17 23:59:59")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-02-18 00:00:00"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-01-02 00:00:00"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-02-17 23:59:59")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-01-02 00:00:00"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"7"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-01-02 00:00:00"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-02-17 23:59:59")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"8"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-01-02 00:00:00"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-02-17 23:59:59")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"8"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-02-18 00:00:00"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"9"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-02-18 00:00:00"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"10"),(0,r.kt)("td",{parentName:"tr",align:null},"2023-02-18 00:00:00"),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("p",null,"The following modifications are made:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Property with id 1,5 and 7 are added. It is valid from 02 January 2023 to the end of 17 February 2023. Because it was in\xa0",(0,r.kt)("inlineCode",{parentName:"li"},"02_01_2023.csv"),"\xa0but not\xa0",(0,r.kt)("inlineCode",{parentName:"li"},"today.csv")),(0,r.kt)("li",{parentName:"ul"},"A new line for properties 4 and 8 is added. Because the price of this property changes between\xa0",(0,r.kt)("inlineCode",{parentName:"li"},"02_01_2023.csv"),"and\xa0",(0,r.kt)("inlineCode",{parentName:"li"},"today.csv")),(0,r.kt)("li",{parentName:"ul"},"For property 6, the value of\xa0",(0,r.kt)("inlineCode",{parentName:"li"},"valid_from"),"\xa0is modified from\xa0",(0,r.kt)("inlineCode",{parentName:"li"},"2023--02--18 00:00:00"),"\xa0to\xa0",(0,r.kt)("inlineCode",{parentName:"li"},"2023--01--02 00:00:00"),"\xa0. Because this property appears in 2 files and its price is unchanged, we should take the more ancient timestamp."),(0,r.kt)("li",{parentName:"ul"},"Property 9 and 10 data remain unchanged.")),(0,r.kt)("p",null,"Given this complexity, we have 2 options:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We remove data from the date we want to reload. Then reload data from that date. This is easier to do but can take longer time to finish if you have a lot of data."),(0,r.kt)("li",{parentName:"ul"},"We load only data for the date and update data for later days.")),(0,r.kt)("p",null,"In this lab, we take the first option. To load data in\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"02_01_2023.csv"),", we first need to remove data from that date. Then rerun the load function for\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"02_01_2023.csv"),"\xa0and\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"today.csv"),"."),(0,r.kt)("p",null,"In the previous section, we only run the ingestion and transformation steps for the current date. We need to modify those functions by including a new parameter\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"for_date"),". Then, we set the value of\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"valid_from"),"\xa0and\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"expired"),"\xa0field according to\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"for_date"),"."),(0,r.kt)("p",null,"For the transformation step, we will need to adjust the condition. In the previous version, we take the rows where the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"expired"),"\xa0field is\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"NULL"),"\xa0because we were running for the current day."),(0,r.kt)("p",null,"If we recompute data in the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"housing_model"),"\xa0table for day D given the following days' data has been loaded in the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"housing_staging"),"\xa0table, we will only take rows that are valid until day D and are expired from the end of day D or are still active."),(0,r.kt)("p",null,"And that's it, you have the data ingestion and transformation necessary to analyze housing price data over time."),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"In this lab, we applied change data capture and slowly changing dimension type 2 modelization to build a model for housing price analysis."))}u.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[78155],{3905:(e,a,t)=>{t.d(a,{Zo:()=>m,kt:()=>p});var n=t(67294);function l(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach((function(a){l(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function r(e,a){if(null==e)return{};var t,n,l=function(e,a){if(null==e)return{};var t,n,l={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||(l[t]=e[t]);return l}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var o=n.createContext({}),d=function(e){var a=n.useContext(o),t=a;return e&&(t="function"==typeof e?e(a):s(s({},a),e)),t},m=function(e){var a=d(e.components);return n.createElement(o.Provider,{value:a},e.children)},u={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},c=n.forwardRef((function(e,a){var t=e.components,l=e.mdxType,i=e.originalType,o=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),c=d(t),p=l,h=c["".concat(o,".").concat(p)]||c[p]||u[p]||i;return t?n.createElement(h,s(s({ref:a},m),{},{components:t})):n.createElement(h,s({ref:a},m))}));function p(e,a){var t=arguments,l=a&&a.mdxType;if("string"==typeof e||l){var i=t.length,s=new Array(i);s[0]=c;var r={};for(var o in a)hasOwnProperty.call(a,o)&&(r[o]=a[o]);r.originalType=e,r.mdxType="string"==typeof e?e:l,s[1]=r;for(var d=2;d<i;d++)s[d]=t[d];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}c.displayName="MDXCreateElement"},81169:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var n=t(87462),l=(t(67294),t(3905));const i={},s="Create a Data Model for an Email System",r={unversionedId:"data-modeling/lab-cassandra-email-data-model/README",id:"data-modeling/lab-cassandra-email-data-model/README",title:"Create a Data Model for an Email System",description:"Conceptual Data Model",source:"@site/docs/04-data-modeling/lab-cassandra-email-data-model/README.md",sourceDirName:"04-data-modeling/lab-cassandra-email-data-model",slug:"/data-modeling/lab-cassandra-email-data-model/",permalink:"/docs/data-modeling/lab-cassandra-email-data-model/",draft:!1,tags:[],version:"current",lastUpdatedBy:"sparsh",lastUpdatedAt:1681047270,formattedLastUpdatedAt:"Apr 9, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Create a Data Model for a Digital Music Library",permalink:"/docs/data-modeling/lab-cassandra-digital-music-library/"},next:{title:"Hotel Reservations Data Modeling with Cassandra",permalink:"/docs/data-modeling/lab-cassandra-hotel-reservations/"}},o={},d=[{value:"Conceptual Data Model",id:"conceptual-data-model",level:2},{value:"Application workflow",id:"application-workflow",level:2},{value:"Logical Data model",id:"logical-data-model",level:2},{value:"Physical Data Model",id:"physical-data-model",level:2},{value:"Hands-on",id:"hands-on",level:2},{value:"Create Keyspace",id:"create-keyspace",level:3},{value:"Create Tables",id:"create-tables",level:3},{value:"Populate tables",id:"populate-tables",level:3},{value:"Design query Q1",id:"design-query-q1",level:3},{value:"Design query Q2",id:"design-query-q2",level:3},{value:"Design query Q3",id:"design-query-q3",level:3},{value:"Design query Q4",id:"design-query-q4",level:3},{value:"Design query Q5",id:"design-query-q5",level:3},{value:"Design query Q6",id:"design-query-q6",level:3}],m={toc:d};function u(e){let{components:a,...t}=e;return(0,l.kt)("wrapper",(0,n.Z)({},m,t,{components:a,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"create-a-data-model-for-an-email-system"},"Create a Data Model for an Email System"),(0,l.kt)("h2",{id:"conceptual-data-model"},"Conceptual Data Model"),(0,l.kt)("p",null,"A conceptual data model is designed with the goal of understanding data in a particular domain. In this example, the model is captured using an Entity-Relationship Diagram (ERD) that documents entity types, relationship types, attribute types, and cardinality and key constraints."),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/214248154-dba659ef-cf4e-46f3-9239-57584ca9f909.png",alt:null})),(0,l.kt)("p",null,"The conceptual data model for messaging data features users, folders, emails and email attachments. A user is identified by a unique username and may have other attributes like name. A folder has a label and color, and is uniquely identified by a combination of a label and username. An email has a unique id, timestamp, one or more recipients, one sender, subject and body. While a user can own many folders, each folder can only belong to one user. Similarly, an email can have many attachments, but an attachment always belongs to exactly one email. Finally, a user can have multiple emails and each email can be seen by multiple users. Since an email can have many labels, it can appear in many folders."),(0,l.kt)("h2",{id:"application-workflow"},"Application workflow"),(0,l.kt)("p",null,"An application workflow is designed with the goal of understanding data access patterns for a data-driven application. Its visual representation consists of application tasks, dependencies among tasks, and data access patterns. Ideally, each data access pattern should specify what attributes to search for, search on, order by, or do aggregation on."),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/214248142-9b916756-9267-4aa5-ac85-ba8f99a3e6e1.png",alt:null})),(0,l.kt)("p",null,"First, the application workflow has an entry-point task that shows all folders that belong to a particular user. This task requires querying a database to find information about folder labels, colors and unread email quantities for a given user, which is documented as Q1 on the diagram. Second, an application can proceed to display all emails with a given label based on a user folder selection, which requires data access pattern Q2. The resulting list of emails should be sorted using email timestamps, showing the most recent emails at the top. Third, the next task can show all information about an individual email selected by a user, which requires data access pattern Q3. Finally, the task of downloading an individual email attachment is based on data access pattern Q4. All in all, there are four data access patterns for a database to support."),(0,l.kt)("h2",{id:"logical-data-model"},"Logical Data model"),(0,l.kt)("p",null,"A logical data model results from a conceptual data model by organizing data into Cassandra-specific data structures based on data access patterns identified by an application workflow. Logical data models can be conveniently captured and visualized using Chebotko Diagrams that can feature tables, materialized views, indexes and so forth."),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/214248160-3867a4f2-a31e-4cd4-918a-c3ddf20205ca.png",alt:null})),(0,l.kt)("p",null,"The logical data model for messaging data is represented by the shown Chebotko Diagram. There are four tables, namely folders_by_user, emails_by_user_folder, emails and attachments, that are designed to specifically support data access patterns Q1, Q2, Q3 and Q4, respectively. Table folders_by_user is designed to have a separate partition for each user, and each partition can contain multiple rows capturing information about individual folders. Therefore, Q1 can be satisfied by retrieving all rows from one partition. Table emails_by_user_folder has a composite partition key, consisting of columns username and label, and a composite clustering key, consisting of columns timestamp and id. It is designed to store all emails that belong to the same folder in one partition, where each individual email maps to a row. Similarly to Q1, Q2 can be satisfied by accessing only one partition. Finally, tables emails and attachments are single-row partition tables that are designed to store one email or one attachment per partition, respectively. Access patterns Q3 and Q4 require retrieving one row from one partition. While this design is straightforward, notice how each email or attachment is intended to be stored only one time, even though they can be accessed by many users via many folders."),(0,l.kt)("h2",{id:"physical-data-model"},"Physical Data Model"),(0,l.kt)("p",null,"A physical data model is directly derived from a logical data model by analyzing and optimizing for performance. The most common type of analysis is identifying potentially large partitions. Some common optimization techniques include splitting and merging partitions, data indexing, data aggregation and concurrent data access optimizations."),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/214248167-78290bd2-fcf7-40c3-a90d-6f16f3a753db.png",alt:null})),(0,l.kt)("p",null,"The physical data model for messaging data is visualized using the Chebotko Diagram. This time, all table columns have associated data types. In addition, every table has some column-related changes, and there is even one new table. Table folders_by_user no longer has column num_unread as it is now part of new table unread_email_stats. The new table is necessary to be able to use the COUNTER data type: any table with one or more counter columns cannot have non-counter columns other than primary key columns. Tables emails_by_user_folder and emails no longer have separate columns to store email timestamps because, in both cases, timestamps can be easily extracted from column id of type TIMEUUID. Furthermore, in the case of table emails_by_user_folder, the clustering order is going to be based on timestamps. It is worth mentioning that partitions in table emails_by_user_folder can grow over time to become very large. However, instead of introducing a new column into the partition key, overflow labels can be used. For example, if a folder with the inbox label becomes too big, the system can automatically start using a new label like inbox-overflow-1 to store more emails, which should be transparent to the user. Finally, column chunk_number is introduced into the partition key of table attachments to be able to divide large attachments into smaller chunks and store them separately. For example, assuming the chunk size limit of 1000KB, a 530KB file can be stored as one chunk and a 2416KB file has to be stored using three chunks. This optimization helps to store and retrieve large attachments faster since different nodes in a cluster may be able to handle different chunks in parallel. Our final blueprint is ready to be instantiated in Cassandra."),(0,l.kt)("h2",{id:"hands-on"},"Hands-on"),(0,l.kt)("p",null,"In this lab, you will:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Create tables for a messaging data use case"),(0,l.kt)("li",{parentName:"ul"},"Populate tables with sample messaging data"),(0,l.kt)("li",{parentName:"ul"},"Design and execute CQL queries over messaging data")),(0,l.kt)("h3",{id:"create-keyspace"},"Create Keyspace"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE KEYSPACE messaging_data\nWITH replication = {\n  'class': 'SimpleStrategy', \n  'replication_factor': 1 }; \n\nUSE messaging_data;\n")),(0,l.kt)("h3",{id:"create-tables"},"Create Tables"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE IF NOT EXISTS folders_by_user (\n  username TEXT,\n  label TEXT,\n  color TEXT,\n  PRIMARY KEY ((username),label)\n);\n\nCREATE TABLE IF NOT EXISTS unread_email_stats (\n  username TEXT,\n  label TEXT,\n  num_unread COUNTER,\n  PRIMARY KEY ((username),label)\n);\n\nCREATE TABLE IF NOT EXISTS emails_by_user_folder (\n  username TEXT,\n  label TEXT,\n  id TIMEUUID,\n  "from" TEXT,\n  subject TEXT,\n  is_read BOOLEAN,\n  PRIMARY KEY ((username,label),id)\n) WITH CLUSTERING ORDER BY (id DESC);\n\nCREATE TABLE IF NOT EXISTS emails (\n  id TIMEUUID,\n  "to" LIST<TEXT>,\n  "from" TEXT,\n  subject TEXT,\n  body TEXT,\n  attachments MAP<TEXT,INT>,\n  PRIMARY KEY ((id))\n);\n\nCREATE TABLE IF NOT EXISTS attachments (\n  email_id TIMEUUID,\n  filename TEXT,\n  chunk_number INT,\n  type TEXT,\n  value BLOB,\n  PRIMARY KEY ((email_id,filename,chunk_number))\n);\n\nDESCRIBE TABLES;\n')),(0,l.kt)("h3",{id:"populate-tables"},"Populate tables"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SOURCE 'messaging_data.cql'\n")),(0,l.kt)("p",null,"Retrieve some rows from tables:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},'SELECT * FROM folders_by_user;        \nSELECT * FROM unread_email_stats;\nSELECT * FROM emails_by_user_folder;                    \nSELECT id, "to", "from" FROM emails; \nSELECT id, subject, body FROM emails; \nSELECT id, attachments FROM emails;\nSELECT * FROM attachments;  \n')),(0,l.kt)("h3",{id:"design-query-q1"},"Design query Q1"),(0,l.kt)("p",null,"Find all folder labels and colors for user ",(0,l.kt)("a",{parentName:"p",href:"mailto:joe@datastax.com"},"joe@datastax.com"),":"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Show me the Answer! "),"```sql SELECT label, color FROM folders_by_user WHERE username = 'joe@datastax.com'; ```"),(0,l.kt)("br",null),(0,l.kt)("h3",{id:"design-query-q2"},"Design query Q2"),(0,l.kt)("p",null,"Find all folder labels and unread email quantities for user ",(0,l.kt)("a",{parentName:"p",href:"mailto:joe@datastax.com"},"joe@datastax.com"),":"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Show me the Answer! "),"```sql SELECT label, num_unread FROM unread_email_stats WHERE username = 'joe@datastax.com'; ```"),(0,l.kt)("br",null),(0,l.kt)("h3",{id:"design-query-q3"},"Design query Q3"),(0,l.kt)("p",null,"Find ids, subjects, senders, read/unread statuses and timestamps of all emails with label inbox for user ",(0,l.kt)("a",{parentName:"p",href:"mailto:joe@datastax.com"},"joe@datastax.com"),"; order by timestamp (desc):"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Show me the Answer! "),"```sql SELECT id, subject, \"from\", is_read, toTimestamp(id) AS timestamp FROM emails_by_user_folder WHERE label = 'inbox' AND username = 'joe@datastax.com'; ```"),(0,l.kt)("br",null),(0,l.kt)("h3",{id:"design-query-q4"},"Design query Q4"),(0,l.kt)("p",null,"Find all available information about an email with id 8ae31dd0-d361-11ea-a40e-5dd6331dfc45:"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Show me the Answer! "),'```sql SELECT id, "to", "from", toTimestamp(id) AS timestamp, subject, body, attachments FROM emails WHERE id = 8ae31dd0-d361-11ea-a40e-5dd6331dfc45; ```'),(0,l.kt)("br",null),(0,l.kt)("h3",{id:"design-query-q5"},"Design query Q5"),(0,l.kt)("p",null,"Find an attachment file with name Budget.xlsx for an email with id 8ae31dd0-d361-11ea-a40e-5dd6331dfc45, assuming that the complete file is stored in one partition with chunk number 1:"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Show me the Answer! "),"```sql SELECT filename, type, value, blobAsText(value) FROM attachments WHERE email_id = 8ae31dd0-d361-11ea-a40e-5dd6331dfc45 AND filename = 'Budget.xlsx' AND chunk_number = 1; ```"),(0,l.kt)("br",null),(0,l.kt)("h3",{id:"design-query-q6"},"Design query Q6"),(0,l.kt)("p",null,"Find an attachment file with name Presentation.pptx for an email with id 8ae31dd0-d361-11ea-a40e-5dd6331dfc45, assuming that the three file chunks are stored across three partitions with chunk numbers 1, 2 and 3:"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Show me the Answer! "),"```sql SELECT filename, type, value, blobAsText(value) FROM attachments WHERE email_id = 8ae31dd0-d361-11ea-a40e-5dd6331dfc45 AND filename = 'Presentation.pptx' AND chunk_number IN (1,2,3); ```"),(0,l.kt)("br",null))}u.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[51325],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>p});var n=a(67294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,i=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),h=d(a),p=s,m=h["".concat(l,".").concat(p)]||h[p]||u[p]||i;return a?n.createElement(m,o(o({ref:t},c),{},{components:a})):n.createElement(m,o({ref:t},c))}));function p(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=a.length,o=new Array(i);o[0]=h;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:s,o[1]=r;for(var d=2;d<i;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},405:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var n=a(87462),s=(a(67294),a(3905));const i={},o="Data Governance",r={unversionedId:"foundations/basics/data-governance",id:"foundations/basics/data-governance",title:"Data Governance",description:"What is Data Governance?",source:"@site/docs/01-foundations/basics/data-governance.md",sourceDirName:"01-foundations/basics",slug:"/foundations/basics/data-governance",permalink:"/docs/foundations/basics/data-governance",draft:!1,tags:[],version:"current",lastUpdatedBy:"sparsh",lastUpdatedAt:1681212836,formattedLastUpdatedAt:"Apr 11, 2023",frontMatter:{},sidebar:"docs",previous:{title:"Data Contract",permalink:"/docs/foundations/basics/data-contract"},next:{title:"Data Management",permalink:"/docs/foundations/basics/data-management"}},l={},d=[{value:"What is Data Governance?",id:"what-is-data-governance",level:2},{value:"Data Usability",id:"data-usability",level:2},{value:"Data Quality",id:"data-quality",level:2},{value:"Correctness",id:"correctness",level:3},{value:"Completeness",id:"completeness",level:3},{value:"Detecting anomalies",id:"detecting-anomalies",level:3},{value:"Data Availability",id:"data-availability",level:2},{value:"Data Security",id:"data-security",level:2},{value:"Data Lineage",id:"data-lineage",level:2}],c={toc:d};function u(e){let{components:t,...a}=e;return(0,s.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"data-governance"},"Data Governance"),(0,s.kt)("h2",{id:"what-is-data-governance"},"What is Data Governance?"),(0,s.kt)("p",null,"Data governance refers to defining and implementing strategies that ensure the organizational data is consistent, reliable, and meets the business needs of the data consumers. To achieve this, an effective data governance strategy defines policies that specify where the data is stored, what data is stored, who can access what kind of data, how the data is processed, and the standards of an organizational dataset that enable data-driven decision-making."),(0,s.kt)("h2",{id:"data-usability"},"Data Usability"),(0,s.kt)("p",null,"This policy requires the data to be in a usable format for business users meaning datasets must be clearly structured and easily accessible. Some of the duties that data engineers need to perform to ensure data usability are:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Provide user documentation of datasets \u2014 specify how and where to access the data, mention the business value and when to use the dataset, and clearly describe the dataset attributes (metadata)."),(0,s.kt)("li",{parentName:"ul"},"Make data compatible with tools used by business users \u2014 this may require data engineers to push the final dataset into different platforms or business intelligence tools used by the downstream consumers.")),(0,s.kt)("h2",{id:"data-quality"},"Data Quality"),(0,s.kt)("p",null,"Testing code is part of the software engineering discipline. In the data engineering world, the equivalent is testing data. While conceptually similar, there is a major difference between the two. Once the code gets written and tested, we can expect the tests to keep passing unless the code is modified. On the other hand, in a data platform, data keeps moving. We might ingest bad data due to an issue upstream, or we might output corrupt data due to a processing issue. Data quality tests need to run all the time, as data moves, to uncover such issues."),(0,s.kt)("p",null,"Data Quality policy ensures that the data is accurate, free of anomalies, and fits the purpose it is intended for. Poor data quality can lead to incorrect insights and negative impacts on business operations. Data engineers need to have data quality as their high priority in all stages (extract, transform, and load) of building a data pipeline, and here are some of the tips:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Perform row-level count checks for source data."),(0,s.kt)("li",{parentName:"ul"},"Have data transformation checks \u2014 ensure data integrity is maintained, attributes have appropriate data types, and there is no data loss."),(0,s.kt)("li",{parentName:"ul"},"Perform data validation checks on the final dataset \u2014 threshold checks for null values allowed (if any), range of values, etc. You can use open-source libraries like ",(0,s.kt)("a",{parentName:"li",href:"https://aws.amazon.com/blogs/big-data/test-data-quality-at-scale-with-deequ/"},"Deequ")," to perform unit tests for large datasets."),(0,s.kt)("li",{parentName:"ul"},"Have anomaly detection checks in place for datasets."),(0,s.kt)("li",{parentName:"ul"},"Set up alerts for data quality issues and work to fix them ASAP.")),(0,s.kt)("h3",{id:"correctness"},"Correctness"),(0,s.kt)("p",null,"Ensuring\xa0data is available is just the first step. We also need to validate that the data is valid. What\xa0",(0,s.kt)("em",{parentName:"p"},"valid"),"\xa0means depends on the dataset. We can make one check to ensure that some value is always present in a column. A\xa0",(0,s.kt)("em",{parentName:"p"},"correctness test"),"\xa0ensures that data is valid by checking that values are within allowed ranges. Allowed values are specific to each dataset and require domain knowledge to identify."),(0,s.kt)("h3",{id:"completeness"},"Completeness"),(0,s.kt)("p",null,"Availability\xa0tests check that some data is present. Completeness tests check that all data is present. Like correctness tests, a completeness test depends on the dataset and what it means to be complete. A\xa0",(0,s.kt)("em",{parentName:"p"},"completeness test"),"\xa0ensures that all the data is loaded by checking that the volume of data is what we would expect. If possible, we can check for an exact row count. If not, we can check that volume is above a certain threshold."),(0,s.kt)("h3",{id:"detecting-anomalies"},"Detecting anomalies"),(0,s.kt)("p",null,"Anomaly\xa0detection is a deep topic, so we'll just dip our toes here. An\xa0",(0,s.kt)("em",{parentName:"p"},"anomaly detection"),"\xa0test looks for statistical anomalies in the data. This type of test is more flexible than other types and can automatically adjust to changes over time. For example, online shopping spikes during the holiday season, while job searches drop. For this, we can use AI-powered anomaly detection, which automatically learns from historical data and identifies anomalies, taking into account spikes and drops like weekends and holidays."),(0,s.kt)("h2",{id:"data-availability"},"Data Availability"),(0,s.kt)("p",null,"The\xa0simplest type of data test is an availability test, which checks that data is available for a certain date. This is a basic test we can run before running more complicated tests. It doesn't tell us whether the data we ingested is correct or even if we ingested all the data we were expecting to ingest. What it does tell us is that we have at least some data available for the date we are querying for, which means some ingestion happened. Knowing this, we can run more comprehensive tests."),(0,s.kt)("p",null,"Data Availability policy requires that the data is available at the RIGHT time for the business teams to ensure timely decision-making. Data availability is the main responsibility of data engineers, and here are some of the actions they can take to ensure it:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Define Service Level Agreements (SLAs) for datasets \u2014 by having predefined SLAs for datasets, data engineers can decide on the frequency of running data pipelines and set clear expectations with the business teams for the availability of updated datasets."),(0,s.kt)("li",{parentName:"ul"},"Be there for production support \u2014 Data pipelines will run into issues causing data errors. And in those cases, data engineers must inform the end users, analyze the issues, provide an ETA for resolving them, and work to fix them without majorly impacting the downstream activities.")),(0,s.kt)("h2",{id:"data-security"},"Data Security"),(0,s.kt)("p",null,"This policy ensures that the data is classified based on its sensitivity, defines who should have access to what kind of data, and specifies security measures for preventing data breaches. Data engineers need to do these to comply with the data security policies:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Restrict data access to specified users \u2014 this can be implemented in terms of database/table/row level access or in terms of the allowed operations (write/read/update) on the dataset."),(0,s.kt)("li",{parentName:"ul"},"Follow high-level security practices for datasets containing personal identification information, and financial, and other confidential data."),(0,s.kt)("li",{parentName:"ul"},"Data engineering teams are generally provided with access keys/secrets to deploy, test, and run data pipelines that need to be part of application code. Make sure not to commit them to GitHub repositories.")),(0,s.kt)("h2",{id:"data-lineage"},"Data Lineage"),(0,s.kt)("p",null,"This policy provides transparency on data movement and depicts the sources and processes involved in moving data from its source to its destination. Data consumers tend to develop trust in the data they are using by looking at the data lineage."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Data engineers can visually represent data sources (external or internal), transformations applied to the data, the job controlling the data flow, and the timeliness of the data."),(0,s.kt)("li",{parentName:"ul"},"It is also recommended to provide the contact information of the source dataset owners in case the end users want to understand more about the data and the business value derived from the dataset.")))}u.isMDXComponent=!0}}]);
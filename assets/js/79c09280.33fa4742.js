"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[69438],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),u=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(i.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=u(n),d=r,g=m["".concat(i,".").concat(d)]||m[d]||c[d]||s;return n?a.createElement(g,o(o({ref:t},p),{},{components:n})):a.createElement(g,o({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=m;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var u=2;u<s;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},42657:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>l,toc:()=>u});var a=n(87462),r=(n(67294),n(3905));const s={},o="Performance Tuning",l={unversionedId:"foundations/language/sql/performance-tuning",id:"foundations/language/sql/performance-tuning",title:"Performance Tuning",description:"SQL tuning is the process of improving SQL queries to accelerate your servers performance. It's general purpose is to reduce the amount of time it takes a user to receive a result after issuing a query, and to reduce the amount of resources used to process a query.",source:"@site/docs/01-foundations/language/sql/performance-tuning.md",sourceDirName:"01-foundations/language/sql",slug:"/foundations/language/sql/performance-tuning",permalink:"/docs/foundations/language/sql/performance-tuning",draft:!1,tags:[],version:"current",lastUpdatedBy:"sparsh",lastUpdatedAt:1681451444,formattedLastUpdatedAt:"Apr 14, 2023",frontMatter:{},sidebar:"docs",previous:{title:"Window Functions",permalink:"/docs/foundations/language/sql/window-functions"},next:{title:"SQL Joins",permalink:"/docs/foundations/language/sql/joins"}},i={},u=[],p={toc:u};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"performance-tuning"},"Performance Tuning"),(0,r.kt)("p",null,"SQL tuning is the process of improving SQL queries to accelerate your servers performance. It's general purpose is to reduce the amount of time it takes a user to receive a result after issuing a query, and to reduce the amount of resources used to process a query."),(0,r.kt)("p",null,"A database is a piece of software that runs on a computer, and is subject to the same limitations as all software---it can only process as much information as its hardware is capable of handling. The way to make a query run faster is to reduce the number of calculations that the software (and therefore hardware) must perform. To do this, you'll need some understanding of how SQL actually makes calculations. First, let's address some of the high-level things that will affect the number of calculations you need to make, and therefore your querys runtime:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Table size:\xa0If your query hits one or more tables with millions of rows or more, it could affect performance."),(0,r.kt)("li",{parentName:"ul"},"Joins:\xa0If your query joins two tables in a way that substantially increases the row count of the result set, your query is likely to be slow."),(0,r.kt)("li",{parentName:"ul"},"Aggregations:\xa0Combining multiple rows to produce a result requires more computation than simply retrieving those rows.")),(0,r.kt)("p",null,"Query runtime is also dependent on some things that you can't really control related to the database itself:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Other users running queries:\xa0The more queries running concurrently on a database, the more the database must process at a given time and the slower everything will run. It can be especially bad if others are running particularly resource-intensive queries that fulfill some of the above criteria."),(0,r.kt)("li",{parentName:"ul"},"Database software and optimization:\xa0This is something you probably can't control, but if you know the system you're using, you can work within its bounds to make your queries more efficient.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Reducing table size")),(0,r.kt)("p",null,"Filtering the data to include only the observations you need can dramatically improve query speed. How you do this will depend entirely on the problem you're trying to solve. For example, if you've got time series data, limiting to a small time window can make your queries run much more quickly:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT *\n  FROM sample_event_table\n WHERE event_date >= '2014-03-01'\n   AND event_date <  '2014-04-01'\n")),(0,r.kt)("p",null,"Keep in mind that you can always perform exploratory analysis on a subset of data, refine your work into a final query, then remove the limitation and run your work across the entire dataset. The final query might take a long time to run, but at least you can run the intermediate steps quickly."),(0,r.kt)("p",null,"This is why we enforces a LIMIT clause by default\u2014100 rows is often more than you need to determine the next step in your analysis, and it's a small enough dataset that it will return quickly."),(0,r.kt)("p",null,"It's worth noting that LIMIT doesn't quite work the same way with aggregations\u2014the aggregation is performed, then the results are limited to the specified number of rows. So if you're aggregating into one row as below, LIMIT 100 will do nothing to speed up your query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT COUNT(*)\n  FROM sample_event_table\n LIMIT 100\n")),(0,r.kt)("p",null,"If you want to limit the dataset before performing the count (to speed things up), try doing it in a subquery:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT COUNT(*)\n  FROM (\n    SELECT *\n      FROM sample_event_table\n     LIMIT 100\n       ) sub\n")),(0,r.kt)("p",null,"Note: Using LIMIT this will dramatically alter your results, so you should use it to test query logic, but not to get actual results."),(0,r.kt)("p",null,"In general, when working with subqueries, you should make sure to limit the amount of data you're working with in the place where it will be executed first. This means putting the LIMIT in the subquery, not the outer query. Again, this is for making the query run fast so that you can test\u2014NOT for producing good results."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"EXPLAIN")),(0,r.kt)("p",null,"You can add EXPLAIN at the beginning of any (working) query to get a sense of how long it will take. It's not perfectly accurate, but it's a useful tool."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Use Column Names Instead of * in a SELECT Statement")),(0,r.kt)("p",null,"If you are selecting only a few columns from a table there is no need to use SELECT *. Though this is easier to write, it will cost more time for the database to complete the query. By selecting only the columns you need, you are reducing the size of the result table, reducing the network traffic and also in turn boosting the overall performance of the query."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("p",null,"Original query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM SH.sales\n")),(0,r.kt)("p",null,"Improved query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT s.prod_id FROM SH.sales s\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Avoid including a HAVING clause in SELECT statements")),(0,r.kt)("p",null,"The HAVING clause is used to filter the rows after all the rows are selected and it is used like a filter. It is quite useless in a SELECT statement. It works by going through the final result table of the query parsing out the rows that don\u2019t meet the HAVING condition."),(0,r.kt)("p",null,"Example:"),(0,r.kt)("p",null,"Original query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT s.cust_id, count(s.cust_id) FROM SH.sales s GROUP BY s.cust_id HAVING s.cust_id != '1660' AND s.cust_id != '2'\n")),(0,r.kt)("p",null,"Improved query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT s.cust_id,count(cust_id) FROM SH.sales s WHERE s.cust_id != '1660' AND s.cust_id !='2' GROUP BY s.cust_id\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Eliminate Unnecessary DISTINCT Conditions")),(0,r.kt)("p",null,"Considering the case of the following example, the DISTINCT keyword in the original query is unnecessary because the table_name contains the primary key p.ID, which is part of the result set."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("p",null,"Original query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT DISTINCT * FROM SH.sales s JOIN SH.customers c ON s.cust_id= c.cust_id WHERE c.cust_marital_status = 'single'\n")),(0,r.kt)("p",null,"Improved query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM SH.sales s JOIN SH.customers c ON s.cust_id = c.cust_id WHERE c.cust_marital_status='single'\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Un-nest sub queries")),(0,r.kt)("p",null,"Rewriting nested queries as joins often leads to more efficient execution and more effective optimization. In general, sub-query un-nesting is always done for correlated sub-queries with, at most, one table in the FROM clause, which are used in ANY, ALL, and EXISTS predicates. A uncorrelated sub-query, or a sub-query with more than one table in the FROM clause, is flattened if it can be decided, based on the query semantics, that the sub-query returns at most one row."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("p",null,"Original query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM SH.products p WHERE p.prod_id = (SELECT s.prod_id FROM SH.sales s WHERE s.cust_id = 100996 AND s.quantity_sold = 1)\n")),(0,r.kt)("p",null,"Improved query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT p.* FROM SH.products p, sales s WHERE p.prod_id = s.prod_id AND s.cust_id = 100996 AND s.quantity_sold = 1\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Consider using an IN predicate when querying an indexed column")),(0,r.kt)("p",null,"The IN-list predicate can be exploited for indexed retrieval and also, the optimizer can sort the IN-list to match the sort sequence of the index, leading to more efficient retrieval. Note that the IN-list must contain only constants, or values that are constant during one execution of the query block, such as outer references."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("p",null,"Original query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT s.* FROM SH.sales s WHERE s.prod_id = 14 OR s.prod_id = 17\n")),(0,r.kt)("p",null,"Improved query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT s.* FROM SH.sales s WHERE s.prod_id IN (14, 17)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Use EXISTS instead of DISTINCT when using table joins that involves tables having one-to-many relationships")),(0,r.kt)("p",null,"The DISTINCT keyword works by selecting all the columns in the table then parses out any duplicates.Instead, if you use sub query with the EXISTS keyword, you can avoid having to return an entire table."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("p",null,"Original query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT DISTINCT c.country_id, c.country_name FROM SH.countries c,SH.customers e WHERE e.country_id = c.country_id\n")),(0,r.kt)("p",null,"Improved query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT c.country_id, c.country_name FROM SH.countries c WHERE EXISTS (SELECT 'X' FROM SH.customers e WHERE e.country_id = c.country_id)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Try to use UNION ALL in place of UNION")),(0,r.kt)("p",null,"The UNION ALL statement is faster than UNION, because UNION ALL statement does not consider duplicate s, and UNION statement does look for duplicates in a table while selection of rows, whether or not they exist."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("p",null,"Original query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT cust_id FROM SH.sales UNION SELECT cust_id FROM customers\n")),(0,r.kt)("p",null,"Improved query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT cust_id FROM SH.sales UNION ALL SELECT cust_id FROM customers\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Avoid using OR in join conditions")),(0,r.kt)("p",null,"Any time you place an \u2018OR\u2019 in the join condition, the query will slow down by at least a factor of two."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("p",null,"Original query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * \nFROM SH.costs c \nINNER JOIN SH.products p \nON c.unit_price = p.prod_min_price OR c.unit_price = p.prod_list_price\n")),(0,r.kt)("p",null,"Improved query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * \nFROM SH.costs c \nINNER JOIN SH.products p \nON c.unit_price = p.prod_min_price \nUNION ALL \nSELECT * \nFROM SH.costs c \nINNER JOIN SH.products p \nON c.unit_price = p.prod_list_price\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Avoid functions on the right hand side of the operator")),(0,r.kt)("p",null,"Functions or methods are used very often with their SQL queries. Rewriting the query by removing aggregate functions will increase the performance tremendously."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("p",null,"Original query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * \nFROM SH.sales \nWHERE EXTRACT (YEAR FROM TO_DATE (time_id, \u2018DDMON-RR\u2019)) = 2001 AND EXTRACT (MONTH FROM TO_DATE (time_id, \u2018DD-MON-RR\u2019)) = 12\n")),(0,r.kt)("p",null,"Improved query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * \nFROM SH.sales \nWHERE TRUNC (time_id) BETWEEN TRUNC(TO_DATE(\u201812/01/2001\u2019, \u2019mm/dd/yyyy\u2019)) AND TRUNC (TO_DATE (\u201812/30/2001\u2019,\u2019mm/dd/yyyy\u2019))\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Remove any redundant mathematics")),(0,r.kt)("p",null,"There will be times where you will be performing mathematics within an SQL statement. They can be a drag on the performance if written improperly. For each time the query finds a row it will recalculate the math. So eliminating any unnecessary math in the statement will make it perform faster."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("p",null,"Original query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM SH.sales s WHERE s.cust_id + 10000 < 35000\n")),(0,r.kt)("p",null,"Improved query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM SH.sales s WHERE s.cust_id < 25000\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Some of the most Query Optimizations techniques are \u2014")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Use indexes:"),"\xa0Indexes can greatly improve the performance of your queries by allowing the database to quickly locate the data it needs."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Limit the number of rows returned:"),' Use the "LIMIT" clause to limit the number of rows returned by a query. This can improve performance and reduce memory usage.'),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Use the right join type:"),"\xa0Use the appropriate join type (e.g. inner join, left join, right join) based on the specific needs of your query."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Use subqueries wisely:")," Subqueries can be useful, but they can also slow down a query if used excessively. Use subqueries sparingly and make sure they are optimized."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},'Avoid using "SELECT"'),':\xa0Instead of using "SELECT", specify the specific columns you need in your query. This can improve performance and reduce memory usage.'),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Avoid using functions on indexed columns:")," Avoid using functions on indexed columns in the WHERE clause."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Use Temporary table:"),"\xa0Use temporary tables to store intermediate results and then join them with other tables."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Use Explain plan:"),'\xa0Use the "EXPLAIN PLAN" statement to analyze the execution plan of a query and identify any potential performance bottlenecks.'),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Use Partitioning:")," Use partitioning to divide large tables into smaller, more manageable pieces."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Use caching:"),"\xa0Use caching to store the results of frequently-run queries in memory, so they can be retrieved quickly without the need to re-run the query.")))}c.isMDXComponent=!0}}]);
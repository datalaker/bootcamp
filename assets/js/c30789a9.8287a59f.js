"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[29143],{3905:(e,a,t)=>{t.d(a,{Zo:()=>d,kt:()=>b});var n=t(67294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function l(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?l(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function i(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var o=n.createContext({}),u=function(e){var a=n.useContext(o),t=a;return e&&(t="function"==typeof e?e(a):s(s({},a),e)),t},d=function(e){var a=u(e.components);return n.createElement(o.Provider,{value:a},e.children)},c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},m=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),m=u(t),b=r,p=m["".concat(o,".").concat(b)]||m[b]||c[b]||l;return t?n.createElement(p,s(s({ref:a},d),{},{components:t})):n.createElement(p,s({ref:a},d))}));function b(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var l=t.length,s=new Array(l);s[0]=m;var i={};for(var o in a)hasOwnProperty.call(a,o)&&(i[o]=a[o]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var u=2;u<l;u++)s[u]=t[u];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}m.displayName="MDXCreateElement"},64521:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>o,contentTitle:()=>s,default:()=>c,frontMatter:()=>l,metadata:()=>i,toc:()=>u});var n=t(87462),r=(t(67294),t(3905));const l={},s="Lab: Create a Data Model for a Digital Music Library",i={unversionedId:"data-modeling/lab-cassandra-digital-music-library/README",id:"data-modeling/lab-cassandra-digital-music-library/README",title:"Lab: Create a Data Model for a Digital Music Library",description:"Conceptual Data Model",source:"@site/docs/04-data-modeling/lab-cassandra-digital-music-library/README.md",sourceDirName:"04-data-modeling/lab-cassandra-digital-music-library",slug:"/data-modeling/lab-cassandra-digital-music-library/",permalink:"/docs/data-modeling/lab-cassandra-digital-music-library/",draft:!1,tags:[],version:"current",lastUpdatedBy:"sparsh",lastUpdatedAt:1682023347,formattedLastUpdatedAt:"Apr 20, 2023",frontMatter:{},sidebar:"docs",previous:{title:"NoSQL Data Modeling",permalink:"/docs/data-modeling/nosql-data-modeling"},next:{title:"Create a Data Model for an Email System",permalink:"/docs/data-modeling/lab-cassandra-email-data-model/"}},o={},u=[{value:"Conceptual Data Model",id:"conceptual-data-model",level:2},{value:"Application workflow",id:"application-workflow",level:2},{value:"Logical Data model",id:"logical-data-model",level:2},{value:"Physical Data Model",id:"physical-data-model",level:2},{value:"Hands-on",id:"hands-on",level:2},{value:"Create Keyspace",id:"create-keyspace",level:3},{value:"Create Tables",id:"create-tables",level:3},{value:"Populate tables using DSBulk",id:"populate-tables-using-dsbulk",level:3},{value:"Insert rows using the CQL shell",id:"insert-rows-using-the-cql-shell",level:3},{value:"Design query Q1",id:"design-query-q1",level:3},{value:"Design query Q2",id:"design-query-q2",level:3},{value:"Design query Q3",id:"design-query-q3",level:3},{value:"Design query Q4",id:"design-query-q4",level:3},{value:"Design query Q5",id:"design-query-q5",level:3},{value:"Design query Q6",id:"design-query-q6",level:3},{value:"Design query Q7",id:"design-query-q7",level:3},{value:"Design query Q8",id:"design-query-q8",level:3},{value:"Design query Q9",id:"design-query-q9",level:3},{value:"Files",id:"files",level:2}],d={toc:u};function c(e){let{components:a,...t}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"lab-create-a-data-model-for-a-digital-music-library"},"Lab: Create a Data Model for a Digital Music Library"),(0,r.kt)("h2",{id:"conceptual-data-model"},"Conceptual Data Model"),(0,r.kt)("p",null,"A conceptual data model is designed with the goal of understanding data in a particular domain. In this example, the model is captured using an Entity-Relationship Diagram (ERD) that documents entity types, relationship types, attribute types, and cardinality and key constraints."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/214248175-dac60d1b-68f8-4b8d-9ebd-dbbbbdcc9bfa.png",alt:null})),(0,r.kt)("p",null,"The conceptual data model for the digital music library features performers, albums, album tracks and users. A performer has a unique name and is usually classified as a musician or a band. While any performer can have a country affiliation, only a musician can have born and died years and only a band can have a year of when it was founded. An album is uniquely identified by its title and release year, and also features genre information. A track has a number, title and length, and is uniquely identified by a combination of an album title, album year and track number. A user has a unique id and may have other attributes like name. While a performer can release many albums, each album can only belong to one performer. Similarly, an album can have many tracks, but a track always belongs to exactly one album. Finally, a user can listen to many tracks and each track can be played by many users."),(0,r.kt)("h2",{id:"application-workflow"},"Application workflow"),(0,r.kt)("p",null,"An application workflow is designed with the goal of understanding data access patterns for a data-driven application. Its visual representation consists of application tasks, dependencies among tasks, and data access patterns. Ideally, each data access pattern should specify what attributes to search for, search on, order by, or do aggregation on."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/214248044-741b8e20-f4af-4500-9df2-89ba62df2112.png",alt:null})),(0,r.kt)("p",null,"The application workflow diagram has five tasks and nine data access patterns. Four out of five tasks are entry-point tasks. In addition, there can be many different paths in this workflow to explore. One possible scenario is described as follows. First, an application shows a user information and her recent music listening history by retrieving data using data access patterns Q8 and Q9. Second, the user searches for a performer with a specific name, which is supported by Q1. Third, the next task retrieves all albums of the found performer using Q2. The resulting list of albums should be sorted using release years, showing the most recent albums first. Finally, the user picks an album and the application retrieves all the album tracks sorted in the ascending order of their track numbers, which requires data access pattern Q7. At this point, the user may decide to listen to a specific track or the whole album, which would be reflected in her listening history. Alternatively, the user may go back to the album selection task or start a new path by looking for performers, albums or tracks. Take a look at the remaining data access patterns and additional paths in this workflow."),(0,r.kt)("h2",{id:"logical-data-model"},"Logical Data model"),(0,r.kt)("p",null,"A logical data model results from a conceptual data model by organizing data into Cassandra-specific data structures based on data access patterns identified by an application workflow. Logical data models can be conveniently captured and visualized using Chebotko Diagrams that can feature tables, materialized views, indexes and so forth."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/214248226-dd14a733-1f0d-4ba1-9ccc-dfb44230451a.png",alt:null})),(0,r.kt)("p",null,"The logical data model for digital library data is represented by the shown Chebotko Diagram. There are eight tables that are designed to support nine data access patterns. Table performers has single-row partitions with column name being a partition key. This table can efficiently satisfy Q1 by retrieving one partition with one row. Tables albums_by_performer, albums_by_title and albums_by_genre have multi-row partitions. While these tables store the same data about albums, they organize it differently and support different data access patterns. Table albums_by_performer stores one partition per performer with rows representing albums, such that all albums released by a specific performer can be always retrieved from a single partition using Q2. Table albums_by_title supports two data access patterns Q3 and Q4 to retrieve albums based on only album title or both title and year. Q3 may return multiple rows and Q4 may return at most one row. Both Q3 and Q4 only access one partition. Table albums_by_genre is designed to support Q5 that retrieves all albums from a known genre in the descending order of their release years. Next, tables tracks_by_title and tracks_by_album are designed to efficiently support data access patterns Q6 and Q7, respectively. Given a track title, Q6 can retrieve all matching tracks and their information from a single partition of table tracks_by_title. Given an album title and year, Q7 can retrieve all album tracks from a single partition of table tracks_by_album. In case of Q7, returned album tracks are always ordered in the ascending order of track numbers, which is directly supported by the table clustering order. Also, notice that column genre in table tracks_by_album is a static column whose value is shared by all rows in the same partition. This works because genre is an album descriptor and the partition key in this table uniquely identifies an album. Finally, tables users and tracks_by_user are designed to support Q8 and Q9. While the former has single-row partitions and the latter has multi-row partitions, partitions from both tables can be retrieved based on user ids."),(0,r.kt)("h2",{id:"physical-data-model"},"Physical Data Model"),(0,r.kt)("p",null,"A physical data model is directly derived from a logical data model by analyzing and optimizing for performance. The most common type of analysis is identifying potentially large partitions. Some common optimization techniques include splitting and merging partitions, data indexing, data aggregation and concurrent data access optimizations."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/214248245-efbe747b-7e8e-4c4c-ae9d-f8ca56d8b3db.png",alt:null})),(0,r.kt)("p",null,"The physical data model for digital library data is visualized using the Chebotko Diagram. This time, all table columns have associated data types. In addition, table tracks_by_user has a new column as part of its partition key. The optimization here is to split potentially large partitions by introducing column month, which represents the first day of a month, as a partition key column. Consider that a user who plays music non-stop generates a new row for table tracks_by_user every 3 minutes, where 3 minutes is an average track length estimate. The old design allows partitions to grow over time: 20 rows in an hour, 480 rows in a day, 3360 rows in a week, 13440 rows in 4 weeks, 175200 rows in a non-leap year, and so forth. The new design restricts each partition to only contain at most 14880 rows that can be generated in a month. Our final blueprint is ready to be instantiated in Cassandra."),(0,r.kt)("h2",{id:"hands-on"},"Hands-on"),(0,r.kt)("h3",{id:"create-keyspace"},"Create Keyspace"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE KEYSPACE music_data\nWITH replication = {\n  'class': 'SimpleStrategy', \n  'replication_factor': 1 }; \n\nUSE music_data;\n")),(0,r.kt)("h3",{id:"create-tables"},"Create Tables"),(0,r.kt)("p",null,"Create tables performers, albums_by_performer, albums_by_title, albums_by_genre, tracks_by_title, tracks_by_album, users and tracks_by_user:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"USE music_data;\n\nCREATE TABLE IF NOT EXISTS performers (\n  name TEXT,\n  type TEXT,\n  country TEXT,\n  born INT,\n  died INT,\n  founded INT,\n  PRIMARY KEY ((name))\n);\n\nCREATE TABLE IF NOT EXISTS albums_by_performer (\n  performer TEXT,\n  year INT,\n  title TEXT,\n  genre TEXT,\n  PRIMARY KEY ((performer),year,title)\n) WITH CLUSTERING ORDER BY (year DESC, title ASC);\n\nCREATE TABLE IF NOT EXISTS albums_by_title (\n  title TEXT,\n  year INT,\n  performer TEXT,\n  genre TEXT,\n  PRIMARY KEY ((title),year)\n) WITH CLUSTERING ORDER BY (year DESC);\n\nCREATE TABLE IF NOT EXISTS albums_by_genre (\n  genre TEXT,\n  year INT,\n  title TEXT,\n  performer TEXT,\n  PRIMARY KEY ((genre),year,title)\n) WITH CLUSTERING ORDER BY (year DESC, title ASC);\n\nCREATE TABLE IF NOT EXISTS tracks_by_title (\n  title TEXT,\n  album_year INT,\n  album_title TEXT,\n  number INT,\n  length INT,\n  genre TEXT,\n  PRIMARY KEY ((title),album_year,album_title,number)\n) WITH CLUSTERING ORDER BY (album_year DESC, album_title ASC, number ASC);\n\nCREATE TABLE IF NOT EXISTS tracks_by_album (\n  album_title TEXT,\n  album_year INT,\n  number INT,\n  title TEXT,\n  length INT,\n  genre TEXT STATIC,\n  PRIMARY KEY ((album_title,album_year),number)\n);\n\nCREATE TABLE IF NOT EXISTS users (\n  id UUID,\n  name TEXT,\n  PRIMARY KEY ((id))\n);\n\nCREATE TABLE IF NOT EXISTS tracks_by_user (\n  id UUID,\n  month DATE,\n  timestamp TIMESTAMP,\n  album_title TEXT,\n  album_year INT,\n  number INT,\n  title TEXT,\n  length INT,\n  PRIMARY KEY ((id,month),timestamp,album_title,album_year,number)\n) WITH CLUSTERING ORDER BY (timestamp DESC, album_title ASC, album_year ASC, number ASC);\n")),(0,r.kt)("p",null,"Verify that the eight tables have been created:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},'cqlsh -k music_data -e "DESCRIBE TABLES;"')),(0,r.kt)("h3",{id:"populate-tables-using-dsbulk"},"Populate tables using DSBulk"),(0,r.kt)("p",null,"Load data into table performers:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"dsbulk load -url performers.csv  \\\n            -k music_data               \\\n            -t performers               \\\n            -header true                \\\n            -logDir /tmp/logs\n")),(0,r.kt)("p",null,"Retrieve some rows from table performers:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},'cqlsh -e "SELECT * FROM music_data.performers LIMIT 10;" ')),(0,r.kt)("p",null,"Load data into tables albums_by_performer, albums_by_title and albums_by_genre:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"dsbulk load -url assets/albums.csv      \\\n            -k music_data               \\\n            -t albums_by_performer      \\\n            -header true                \\\n            -logDir /tmp/logs\n\ndsbulk load -url assets/albums.csv      \\\n            -k music_data               \\\n            -t albums_by_title          \\\n            -header true                \\\n            -logDir /tmp/logs\n\ndsbulk load -url assets/albums.csv      \\\n            -k music_data               \\\n            -t albums_by_genre          \\\n            -header true                \\\n            -logDir /tmp/logs\n")),(0,r.kt)("p",null,"Retrieve some rows from tables albums_by_performer, albums_by_title and albums_by_genre:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},'cqlsh -e "SELECT * FROM music_data.albums_by_performer LIMIT 5;"   \ncqlsh -e "SELECT * FROM music_data.albums_by_title LIMIT 5;"   \ncqlsh -e "SELECT * FROM music_data.albums_by_genre LIMIT 5;"\n')),(0,r.kt)("p",null,"Load data into tables tracks_by_title and tracks_by_album:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},'dsbulk load -url assets/tracks.csv      \\\n            -k music_data               \\\n            -t tracks_by_title          \\\n            -header true                \\\n            -m "0=album_title,          \\\n                1=album_year,           \\\n                2=genre,                \\\n                3=number,               \\\n                4=title"                \\\n            -logDir /tmp/logs\n\ndsbulk load -url assets/tracks.csv      \\\n            -k music_data               \\\n            -t tracks_by_album          \\\n            -header true                \\\n            -m "0=album_title,          \\\n                1=album_year,           \\\n                2=genre,                \\\n                3=number,               \\\n                4=title"                \\\n            -logDir /tmp/logs\n')),(0,r.kt)("p",null,"Retrieve some rows from tables tracks_by_title and tracks_by_album:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},'cqlsh -e "SELECT * FROM music_data.tracks_by_title LIMIT 5;"   \ncqlsh -e "SELECT * FROM music_data.tracks_by_album LIMIT 5;" \n')),(0,r.kt)("h3",{id:"insert-rows-using-the-cql-shell"},"Insert rows using the CQL shell"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"cqlsh -k music_data\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO users (id, name)\nVALUES (12345678-aaaa-bbbb-cccc-123456789abc, 'Joe'); \nINSERT INTO users (id, name)\nVALUES (UUID(), 'Jen'); \nINSERT INTO users (id, name)\nVALUES (UUID(), 'Jim'); \n\nSELECT * FROM users;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO tracks_by_user (id, month, timestamp, album_title, album_year, number, title)\nVALUES (12345678-aaaa-bbbb-cccc-123456789abc, '2020-01-01', '2020-01-05T11:22:33', '20 Greatest Hits', 1982, 16, 'Hey Jude');\n\nINSERT INTO tracks_by_user (id, month, timestamp, album_title, album_year, number, title)\nVALUES (12345678-aaaa-bbbb-cccc-123456789abc, '2020-09-01', '2020-09-15T09:00:00', '20 Greatest Hits', 1982, 16, 'Hey Jude');\n\nINSERT INTO tracks_by_user (id, month, timestamp, album_title, album_year, number, title)\nVALUES (12345678-aaaa-bbbb-cccc-123456789abc, '2020-09-01', '2020-09-15T16:41:10', 'Legendary Concert Performances', 1978, 6, 'Johnny B. Goode');\n\nINSERT INTO tracks_by_user (id, month, timestamp, album_title, album_year, number, title)\nVALUES (12345678-aaaa-bbbb-cccc-123456789abc, '2020-09-01', '2020-09-15T16:44:56', 'The Beatles 1967-1970', 1973, 17, 'Come Together');\n\nINSERT INTO tracks_by_user (id, month, timestamp, album_title, album_year, number, title)\nVALUES (12345678-aaaa-bbbb-cccc-123456789abc, '2020-09-01', '2020-09-15T21:13:13', 'Dark Side Of The Moon', 1973, 3, 'Time');\n\nSELECT * FROM tracks_by_user;\n")),(0,r.kt)("h3",{id:"design-query-q1"},"Design query Q1"),(0,r.kt)("p",null,"Find a performer with name The Beatles:"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Show me the Answer! "),"```sql SELECT * FROM performers WHERE name = 'The Beatles'; ```"),(0,r.kt)("br",null),(0,r.kt)("h3",{id:"design-query-q2"},"Design query Q2"),(0,r.kt)("p",null,"Find albums of performer The Beatles; order by year (desc):"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Show me the Answer! "),"SELECT * FROM albums_by_performer WHERE performer = 'The Beatles';"),(0,r.kt)("br",null),(0,r.kt)("h3",{id:"design-query-q3"},"Design query Q3"),(0,r.kt)("p",null,"Find an album with title Magical Mystery Tour and year 1967:"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Show me the Answer! "),"SELECT * FROM albums_by_title WHERE title = 'Magical Mystery Tour' AND year  = 1967;"),(0,r.kt)("br",null),(0,r.kt)("h3",{id:"design-query-q4"},"Design query Q4"),(0,r.kt)("p",null,"Find albums with title 20 Greatest Hits; order by year (desc):"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Show me the Answer! "),"SELECT * FROM albums_by_title WHERE title = '20 Greatest Hits';"),(0,r.kt)("br",null),(0,r.kt)("h3",{id:"design-query-q5"},"Design query Q5"),(0,r.kt)("p",null,"Find albums from genre Classical; order by year (desc):"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Show me the Answer! "),"SELECT * FROM albums_by_genre WHERE genre = 'Classical';"),(0,r.kt)("br",null),(0,r.kt)("h3",{id:"design-query-q6"},"Design query Q6"),(0,r.kt)("p",null,"Find tracks with title Let It Be:"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Show me the Answer! "),"SELECT * FROM tracks_by_title WHERE title = 'Let It Be';"),(0,r.kt)("br",null),(0,r.kt)("h3",{id:"design-query-q7"},"Design query Q7"),(0,r.kt)("p",null,"Find tracks from album Magical Mystery Tour of 1967; order by track number (asc):"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Show me the Answer! "),"SELECT * FROM tracks_by_album WHERE album_title = 'Magical Mystery Tour' AND album_year  = 1967;"),(0,r.kt)("br",null),(0,r.kt)("h3",{id:"design-query-q8"},"Design query Q8"),(0,r.kt)("p",null,"Find a user with id 12345678-aaaa-bbbb-cccc-123456789abc:"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Show me the Answer! "),"SELECT * FROM users WHERE id = 12345678-aaaa-bbbb-cccc-123456789abc;"),(0,r.kt)("br",null),(0,r.kt)("h3",{id:"design-query-q9"},"Design query Q9"),(0,r.kt)("p",null,"Find all tracks played by the user in September 2020; order by timestamp (desc):"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Show me the Answer! "),"SELECT timestamp, album_title, album_year, number, title FROM tracks_by_user WHERE id = 12345678-aaaa-bbbb-cccc-123456789abc AND month = '2020-09-01';"),(0,r.kt)("br",null),(0,r.kt)("h2",{id:"files"},"Files"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/sparsh-ai/recohut/tree/main/docs/04-data-modeling/lab-cassandra-digital-music-library"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/GitHub-100000?style=for-the-badge&logo=github&logoColor=white",alt:"Github"}))))}c.isMDXComponent=!0}}]);
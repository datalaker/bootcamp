"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[47658],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>h});var r=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=r.createContext({}),c=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},d=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=c(a),h=n,m=p["".concat(l,".").concat(h)]||p[h]||u[h]||i;return a?r.createElement(m,s(s({ref:t},d),{},{components:a})):r.createElement(m,s({ref:t},d))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,s=new Array(i);s[0]=p;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:n,s[1]=o;for(var c=2;c<i;c++)s[c]=a[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,a)}p.displayName="MDXCreateElement"},57259:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var r=a(87462),n=(a(67294),a(3905));const i={},s="Big Data",o={unversionedId:"foundations/data-engineering-foundations/big-data",id:"foundations/data-engineering-foundations/big-data",title:"Big Data",description:"Six Vs of big data",source:"@site/docs/01-foundations/02-data-engineering-foundations/big-data.md",sourceDirName:"01-foundations/02-data-engineering-foundations",slug:"/foundations/data-engineering-foundations/big-data",permalink:"/docs/foundations/data-engineering-foundations/big-data",draft:!1,tags:[],version:"current",lastUpdatedBy:"sparsh",lastUpdatedAt:1681047270,formattedLastUpdatedAt:"Apr 9, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Batch vs Incremental Data Processing",permalink:"/docs/foundations/data-engineering-foundations/batch-vs-incremental"},next:{title:"Data Contract",permalink:"/docs/foundations/data-engineering-foundations/data-contract"}},l={},c=[{value:"Lambda Architecture",id:"lambda-architecture",level:4},{value:"Kappa Architecture",id:"kappa-architecture",level:4}],d={toc:c};function u(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,r.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"big-data"},"Big Data"),(0,n.kt)("p",null,(0,n.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/213918079-10af46d9-f906-4c3e-9b84-ddc47708bd15.png",alt:"Six Vs of big data"})),(0,n.kt)("h4",{id:"lambda-architecture"},"Lambda Architecture"),(0,n.kt)("p",null,"Lambda architecture comprises Batch Layer, Speed Layer (also known as Stream layer), and Serving Layer."),(0,n.kt)("p",null,"The batch layer operates on the complete data and thus allows the system to produce the most accurate results. However, the results come at the cost of high latency due to high computation time. The batch layer stores the raw data as it arrives and computes the batch views for consumption. Naturally, batch processes will occur at some interval and will be long-lived. The scope of data is anywhere from hours to years."),(0,n.kt)("p",null,"The speed layer generates results in a low-latency, near real-time fashion. The speed layer is used to compute the real-time views to complement the batch views. The speed layer receives the arriving data and performs incremental updates to the batch layer results. Thanks to the incremental algorithms implemented at the speed layer, the computation cost is significantly reduced."),(0,n.kt)("p",null,"The batch views may be processed with more complex or expensive rules and may have better data quality and less skew, while the real-time views give you up-to-the-moment access to the latest possible data."),(0,n.kt)("p",null,"Finally, the serving layer enables various queries of the results sent from the batch and speed layers. The outputs from the batch layer in the form of batch views and the speed layer in the form of near-real-time views are forwarded to the serving layer, which uses this data to cater to the pending queries on an ad-hoc basis."),(0,n.kt)("p",null,(0,n.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/213918086-32e76d06-a398-40ad-9271-16b9ffc3bb6b.png",alt:null})),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Pros")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"It is a good balance of speed, reliability, and scalability. The batch layer of Lambda architecture manages historical data with the fault-tolerant, distributed storage, ensuring a low possibility of errors even if the system crashes."),(0,n.kt)("li",{parentName:"ul"},"Access to both real-time and offline results in covering many data analysis scenarios very well."),(0,n.kt)("li",{parentName:"ul"},"Having access to a complete data set in a batch window may yield specific optimizations that make Lambda better performing and perhaps even simpler to implement.")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Cons")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Although the offline layer and the real-time stream face different scenarios, their internal processing logic is the same, so there are many duplicate modules and coding overhead."),(0,n.kt)("li",{parentName:"ul"},"Reprocesses every batch cycle, which is not beneficial in specific scenarios."),(0,n.kt)("li",{parentName:"ul"},"A data set modeled with Lambda architecture is difficult to migrate or reorganize.")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Use Cases")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"User queries are required to be served on an ad-hoc basis using immutable data storage."),(0,n.kt)("li",{parentName:"ul"},"Quick responses are required, and the system should handle various updates in new data streams."),(0,n.kt)("li",{parentName:"ul"},"None of the stored records shall be erased, and it should allow the addition of updates and new data to the database.")),(0,n.kt)("h4",{id:"kappa-architecture"},"Kappa Architecture"),(0,n.kt)("p",null,"The Kappa architecture solves the redundant part of the Lambda architecture. It is designed with the idea of replaying data. Kappa architecture avoids maintaining two different code bases for the batch and speed layers. The key idea is to handle real-time data processing, and continuous data reprocessing using a single stream processing engine and avoid a multi-layered Lambda architecture while meeting the standard quality of service."),(0,n.kt)("p",null,(0,n.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/213918082-56da8775-caee-4db4-b515-7c20ee2bc6bd.png",alt:null})),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Pros")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Applications can read and write directly to Kafka (or other message queue) as developed. For existing event sources, listeners are used to stream writes directly from database logs (or datastore equivalents), eliminating the need for batch processing during ingress, resulting in fewer resources."),(0,n.kt)("li",{parentName:"ul"},"Treating every data point in your organization as a streaming event also provides you the ability to 'time travel' to any point and see the state of all data in your organization."),(0,n.kt)("li",{parentName:"ul"},"Queries only need to look in a single serving location instead of going against batch and speed views.")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Cons")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The complication of this architecture mainly revolves around having to process this data in a stream, such as handling duplicate events, cross-referencing events, or maintaining order - operations that are generally easier to do in batch processing."),(0,n.kt)("li",{parentName:"ul"},"Although the Kappa architecture looks concise, it isn't easy to implement, especially for the data replay."),(0,n.kt)("li",{parentName:"ul"},"For Lambda, catalog services can auto-discover and document file and database systems. Kafka doesn't align with this tooling, so supporting scaling to enterprise-sized environments strongly infers implementing confluent enterprise with a schema registry that attempts to play the role of a catalog service.")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Use Cases")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"When the algorithms applied to the real-time data and the historical data are identical, it is very beneficial to use the same code base to process historical and real-time data and, therefore, implement the use-case using the Kappa architecture."),(0,n.kt)("li",{parentName:"ul"},"Kappa architecture can be used to develop data systems that are online learners and therefore don't need the batch layer."),(0,n.kt)("li",{parentName:"ul"},"The order of the events and queries is not predetermined. Stream processing platforms can interact with the database at any time.")),(0,n.kt)("p",null,"Kappa is not a replacement for Lambda as some use-cases deployed using the Lambda architecture cannot be migrated."),(0,n.kt)("p",null,"When you seek an architecture that is more reliable in updating the data lake as well as efficient in training the machine learning models to predict upcoming events robustly, then use the Lambda architecture as it reaps the benefits of both the batch layer and speed layer to ensure few errors and speed."),(0,n.kt)("p",null,"On the other hand, when you want to deploy big data architecture using less expensive hardware and require it to deal effectively with unique events occurring continuously, then select the Kappa architecture for your real-time data processing needs."),(0,n.kt)("p",null,"Check out ",(0,n.kt)("a",{parentName:"p",href:"https://www.qlik.com/us/resource-library/modernizing-your-data-architecture-to-unlock-business-value"},"this whitepaper")," and ",(0,n.kt)("a",{parentName:"p",href:"https://videos.qlik.com/watch/mm2p55sd3zvdYHqkzhqRaH?_ga=2.269188596.401343546.1664008674-358725923.1664008674"},"related webinar")," to deep dive into this topic."))}u.isMDXComponent=!0}}]);
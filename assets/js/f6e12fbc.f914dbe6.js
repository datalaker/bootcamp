"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[79906],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>u});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),c=d(a),u=i,m=c["".concat(l,".").concat(u)]||c[u]||h[u]||s;return a?n.createElement(m,o(o({ref:t},p),{},{components:a})):n.createElement(m,o({ref:t},p))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=a.length,o=new Array(s);o[0]=c;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,o[1]=r;for(var d=2;d<s;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},83330:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});var n=a(87462),i=(a(67294),a(3905));const s={},o="Sparkify",r={unversionedId:"capstones/sparkify/README",id:"capstones/sparkify/README",title:"Sparkify",description:"Sparkify SQL Data Modeling with Postgres",source:"@site/docs/12-capstones/sparkify/README.md",sourceDirName:"12-capstones/sparkify",slug:"/capstones/sparkify/",permalink:"/docs/capstones/sparkify/",draft:!1,tags:[],version:"current",lastUpdatedBy:"sparsh",lastUpdatedAt:1681047270,formattedLastUpdatedAt:"Apr 9, 2023",frontMatter:{}},l={},d=[{value:"Sparkify SQL Data Modeling with Postgres",id:"sparkify-sql-data-modeling-with-postgres",level:2},{value:"Songs dataset",id:"songs-dataset",level:3},{value:"Logs dataset",id:"logs-dataset",level:3},{value:"Quality",id:"quality",level:3},{value:"Tidiness",id:"tidiness",level:3},{value:"Database Schema Design - Entity Relation Diagram (ERD)",id:"database-schema-design---entity-relation-diagram-erd",level:3},{value:"Sparkify NoSQL Data Modeling with Cassandra",id:"sparkify-nosql-data-modeling-with-cassandra",level:2},{value:"*<strong>*Event Dataset**</strong>",id:"event-dataset",level:3},{value:"<strong>Keyspace Schema Design</strong>",id:"keyspace-schema-design",level:3},{value:"Sparkify Data Lake with AWS and PySpark",id:"sparkify-data-lake-with-aws-and-pyspark",level:2},{value:"Project Description",id:"project-description",level:3},{value:"Built With",id:"built-with",level:3},{value:"Dataset",id:"dataset",level:3},{value:"Song Dataset",id:"song-dataset",level:4},{value:"Log Dataset",id:"log-dataset",level:4},{value:"Data Model ERD",id:"data-model-erd",level:3},{value:"Problem",id:"problem",level:3},{value:"Solution",id:"solution",level:3},{value:"Getting started",id:"getting-started",level:3},{value:"Sparkify Data Warehouse with Redshift",id:"sparkify-data-warehouse-with-redshift",level:2},{value:"Problem",id:"problem-1",level:3},{value:"Solution",id:"solution-1",level:3},{value:"Getting started",id:"getting-started-1",level:3},{value:"Data Layout",id:"data-layout",level:3},{value:"Transformations",id:"transformations",level:3},{value:"Dimension: Artist",id:"dimension-artist",level:4},{value:"Dimension: Time",id:"dimension-time",level:4},{value:"Sparkify Data Pipeline with Airflow",id:"sparkify-data-pipeline-with-airflow",level:2},{value:"Problem",id:"problem-2",level:3},{value:"Solution",id:"solution-2",level:3},{value:"Getting started",id:"getting-started-2",level:3},{value:"About The Project",id:"about-the-project",level:3},{value:"Project Description",id:"project-description-1",level:3},{value:"Built With",id:"built-with-1",level:3},{value:"Dataset",id:"dataset-1",level:3},{value:"Song Dataset",id:"song-dataset-1",level:4},{value:"Log Dataset",id:"log-dataset-1",level:4},{value:"Database Schema Design",id:"database-schema-design",level:3},{value:"Data Model ERD",id:"data-model-erd-1",level:4},{value:"Apache Airflow Orchestration",id:"apache-airflow-orchestration",level:3},{value:"DAG Structure",id:"dag-structure",level:4},{value:"Operators",id:"operators",level:4},{value:"Stage Operator",id:"stage-operator",level:4},{value:"Fact and Dimension Operators",id:"fact-and-dimension-operators",level:4},{value:"Data Quality Operator",id:"data-quality-operator",level:4},{value:"Airflow UI views of DAG and plugins",id:"airflow-ui-views-of-dag-and-plugins",level:4},{value:"Project structure",id:"project-structure",level:3},{value:"Getting Started",id:"getting-started-3",level:3},{value:"Prerequisites",id:"prerequisites",level:4},{value:"How to run",id:"how-to-run",level:4},{value:"Project Structure",id:"project-structure-1",level:2}],p={toc:d};function h(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"sparkify"},"Sparkify"),(0,i.kt)("h2",{id:"sparkify-sql-data-modeling-with-postgres"},"Sparkify SQL Data Modeling with Postgres"),(0,i.kt)("p",null,"In this, we will model the data with Postgres and build an ETL pipeline using Python. The fact and dimension tables for a star database schema for a particular analytic focus is defined, and an ETL pipeline that transfers data from files in two local directories into these tables in Postgres using Python and SQL was developed."),(0,i.kt)("p",null,"A startup called Sparkify wants to analyze the data they've been collecting on songs and user activity on their new music streaming application. The analytics team is particularly interested in understanding what songs users are listening to. Currently, they don't have an easy way to query their data, which resides in a directory of JSON logs on user activity on the application, as well as a directory with JSON meta-data on the songs in their application."),(0,i.kt)("p",null,"They'd like a data engineer to create a Postgres database with tables designed to optimize queries on song play analysis. The role of this project is to create a database schema and ETL pipeline for this analysis."),(0,i.kt)("p",null,"We will model the data with Postgres and build an ETL pipeline using Python. The fact and dimension tables for a star database schema for a particular analytic focus is defined, and an ETL pipeline that transfers data from files in two local directories into these tables in Postgres using Python and SQL was developed."),(0,i.kt)("h3",{id:"songs-dataset"},"Songs dataset"),(0,i.kt)("p",null,"Songs dataset is a subset of\xa0",(0,i.kt)("a",{parentName:"p",href:"http://millionsongdataset.com/"},"Million Song Dataset"),". Each file in the dataset is in JSON format and contains meta-data about a song and the artist of that song."),(0,i.kt)("p",null,"Sample record:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{"num_songs": 1, "artist_id": "ARJIE2Y1187B994AB7", "artist_latitude": null, "artist_longitude": null, "artist_location": "", "artist_name": "Line Renaud", "song_id": "SOUPIRU12A6D4FA1E1", "title": "Der Kleine Dompfaff", "duration": 152.92036, "year": 0}\n')),(0,i.kt)("h3",{id:"logs-dataset"},"Logs dataset"),(0,i.kt)("p",null,"Logs dataset is generated by\xa0",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Interana/eventsim"},"Event Simulator"),". These log files in JSON format simulate activity logs from a music streaming application based on specified configurations."),(0,i.kt)("p",null,"Sample record:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{"artist": null, "auth": "Logged In", "firstName": "Walter", "gender": "M", "itemInSession": 0, "lastName": "Frye", "length": null, "level": "free", "location": "San Francisco-Oakland-Hayward, CA", "method": "GET","page": "Home", "registration": 1540919166796.0, "sessionId": 38, "song": null, "status": 200, "ts": 1541105830796, "userAgent": "\\"Mozilla\\/5.0 (Macintosh; Intel Mac OS X 10_9_4) AppleWebKit\\/537.36 (KHTML, like Gecko) Chrome\\/36.0.1985.143 Safari\\/537.36\\"", "userId": "39"}\n')),(0,i.kt)("h3",{id:"quality"},"Quality"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"LogDataset : userID - Found users with empty string '', firstName as None"),(0,i.kt)("li",{parentName:"ol"},"LogDataset : Major of the artist_id & song_id is null"),(0,i.kt)("li",{parentName:"ol"},"Artists table doesn't have list of all the artists found in log"),(0,i.kt)("li",{parentName:"ol"},"Songs table doesn't have all the songs found in log"),(0,i.kt)("li",{parentName:"ol"},"LogDataset : Logs are ordered by timestamp, so they need to be sorted. This enables latest user level to be updated in the users table")),(0,i.kt)("h3",{id:"tidiness"},"Tidiness"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"LogDataset : ts : timestamp column as int64 needs to converted to timestamp"),(0,i.kt)("li",{parentName:"ol"},"SongPlays table : Add new column songplay_id as serial ( auto-increment )"),(0,i.kt)("li",{parentName:"ol"},"user : table : Adding column ts"),(0,i.kt)("li",{parentName:"ol"},"songplays : table : Adding columns itemInSession, song, artist")),(0,i.kt)("h3",{id:"database-schema-design---entity-relation-diagram-erd"},"Database Schema Design - Entity Relation Diagram (ERD)"),(0,i.kt)("p",null,"The Star Database Schema used for data modeling in this ETL pipeline. There is one fact table containing all the metrics (facts) associated to each event (user actions), and four dimensions tables, containing associated information such as user name, artist name, song meta-data etc. This model enables to search the database schema with the minimum number of\xa0",(0,i.kt)("em",{parentName:"p"},"SQL JOIN"),"s possible and enable fast read queries. The amount of data we need to analyze is not big enough to require big data solutions or NoSQL databases."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/215310998-b894e4b2-b6ba-4a2d-a84b-531e67a32cbc.png",alt:"data_schema"})),(0,i.kt)("h2",{id:"sparkify-nosql-data-modeling-with-cassandra"},"Sparkify NoSQL Data Modeling with Cassandra"),(0,i.kt)("p",null,"In this, we will model the data with Apache Cassandra and build an ETL pipeline using Python. The ETL pipeline transfers data from a set of CSV files within a directory to create a streamlined CSV file to model and insert data into Apache Cassandra tables. We will create separate denormalized tables for answering specific queries, properly using partition keys and clustering columns."),(0,i.kt)("p",null,"A startup called Sparkify wants to analyze the data they've been collecting on songs and user activity on their new music streaming application. The analytics team is particularly interested in understanding what songs users are listening to. Currently, they don't have an easy way to query their data, which resides in a directory of JSON logs on user activity on the application, as well as a directory with JSON meta-data on the songs in their application."),(0,i.kt)("p",null,"They'd like a data engineer to create a Apache Cassandra database which can create queries on song play data to answer the questions and make meaningful insights. The role of this project is to create a database schema and ETL pipeline for this analysis."),(0,i.kt)("p",null,"We will model the data with Apache Cassandra and build an ETL pipeline using Python. The ETL pipeline transfers data from a set of CSV files within a directory to create a streamlined CSV file to model and insert data into Apache Cassandra tables. We will create separate denormalized tables for answering specific queries, properly using partition keys and clustering columns."),(0,i.kt)("h3",{id:"event-dataset"},"*",(0,i.kt)("strong",{parentName:"h3"},"*Event Dataset**")),(0,i.kt)("p",null,"Event dataset is a collection of CSV files containing the information of user activity across a period of time. Each file in the dataset contains the information regarding the song played, user information and other attributes ."),(0,i.kt)("p",null,"List of available data columns :"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"artist, auth, firstName, gender, itemInSession, lastName, length, level, location, method, page, registration, sessionId, song, status, ts, userId\n")),(0,i.kt)("h3",{id:"keyspace-schema-design"},(0,i.kt)("strong",{parentName:"h3"},"Keyspace Schema Design")),(0,i.kt)("p",null,"The keyspace design is shown in the image below. Each table is modeled to answer a specific known query. This model enables to query the database schema containing huge amounts of data. Relational databases are not suitable in this scenario due to the magnitude of data."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/215310889-b8b76e08-346b-4607-b3ac-a732dd83c442.png",alt:"keyspace"})),(0,i.kt)("h2",{id:"sparkify-data-lake-with-aws-and-pyspark"},"Sparkify Data Lake with AWS and PySpark"),(0,i.kt)("p",null,"In this lab, we will build a data lake on AWS S3 and build an ETL pipeline for a data lake hosted on S3. The data is loaded from S3 and processed into analytics tables using Spark and the processed data is loaded back into S3 in the form of parquet files."),(0,i.kt)("p",null,"The data stored on S3 buckets is extracted and processed using Spark, and is then inserted into the fact and dimensional tables."),(0,i.kt)("p",null,"A startup called Sparkify wants to analyze the data they've been collecting on songs and user activity on their new music streaming application. Sparkify has grown their user base and song database large and want to move their data warehouse to a data lake. Their data resides in S3, in a directory of JSON logs on user activity on the application, as well as a directory with JSON metadata on the songs in their application."),(0,i.kt)("p",null,"They'd like a data engineer to build an ETL pipeline that extracts their data from S3,  processes them using Spark, and loads the data back into S3 as a set of fact and dimensional tables. This will allow their analytics team to continue finding insights in what songs their users are listening to. The role of this project is to create a data lake on cloud (AWS S3) and build ETL pipeline for this process."),(0,i.kt)("h3",{id:"project-description"},"Project Description"),(0,i.kt)("p",null,"In this project, we will build a data lake on AWS S3 and build an ETL pipeline for a data lake hosted on S3. The data is loaded from S3 and processed into analytics tables using Spark and the processed data is loaded back into S3 in the form of parquet files."),(0,i.kt)("h3",{id:"built-with"},"Built With"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"python"),(0,i.kt)("li",{parentName:"ul"},"AWS")),(0,i.kt)("h3",{id:"dataset"},"Dataset"),(0,i.kt)("h4",{id:"song-dataset"},"Song Dataset"),(0,i.kt)("p",null,"Songs dataset is a subset of ",(0,i.kt)("a",{parentName:"p",href:"http://millionsongdataset.com/"},"Million Song Dataset"),". Each file in the dataset is in JSON format and contains meta-data about a song and the artist of that song. The dataset is hosted at S3 bucket ",(0,i.kt)("inlineCode",{parentName:"p"},"s3://sparsh-dend/song_data"),"."),(0,i.kt)("p",null,"Sample Record :"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'{"num_songs": 1, "artist_id": "ARJIE2Y1187B994AB7", "artist_latitude": null, "artist_longitude": null, "artist_location": "", "artist_name": "Line Renaud", "song_id": "SOUPIRU12A6D4FA1E1", "title": "Der Kleine Dompfaff", "duration": 152.92036, "year": 0}\n')),(0,i.kt)("h4",{id:"log-dataset"},"Log Dataset"),(0,i.kt)("p",null,"Logs dataset is generated by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Interana/eventsim"},"Event Simulator"),". These log files in JSON format simulate activity logs from a music streaming application based on specified configurations. The dataset is hosted at S3 bucket ",(0,i.kt)("inlineCode",{parentName:"p"},"s3://sparsh-dend/log_data"),"."),(0,i.kt)("p",null,"Sample Record :"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'{"artist": null, "auth": "Logged In", "firstName": "Walter", "gender": "M", "itemInSession": 0, "lastName": "Frye", "length": null, "level": "free", "location": "San Francisco-Oakland-Hayward, CA", "method": "GET","page": "Home", "registration": 1540919166796.0, "sessionId": 38, "song": null, "status": 200, "ts": 1541105830796, "userAgent": "\\"Mozilla\\/5.0 (Macintosh; Intel Mac OS X 10_9_4) AppleWebKit\\/537.36 (KHTML, like Gecko) Chrome\\/36.0.1985.143 Safari\\/537.36\\"", "userId": "39"}\n')),(0,i.kt)("h3",{id:"data-model-erd"},"Data Model ERD"),(0,i.kt)("p",null,"The Star Database Schema (Fact and Dimension Schema) is used for data modeling in this ETL pipeline. There is one fact table containing all the metrics (facts) associated to each event (user actions), and four dimensions tables, containing associated information such as user name, artist name, song meta-data etc. This model enables to search the database schema with the minimum number of ",(0,i.kt)("em",{parentName:"p"},"SQL JOIN"),"s possible and enable fast read queries."),(0,i.kt)("p",null,"The data stored on S3 buckets is extracted and processed using Spark, and is then inserted into the fact and dimensional tables. This tables are stored back to S3 in parquet files, organized for optimal performance. An entity relationship diagram (ERD) of the data model is given below."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/215310795-2ba21d81-1c32-4e7b-b6d6-9de37c5d002e.png",alt:"database"})),(0,i.kt)("p",null,"In this project (Py)Spark is used to process large amount of data for a\nfictional music streaming service, which is called Sparkify."),(0,i.kt)("h3",{id:"problem"},"Problem"),(0,i.kt)("p",null,"The scenario that should be solved in this project is:\nSparkify has gained a lot new users and the song database as well as the\nrecorded song plays have increased over time."),(0,i.kt)("p",null,"Sparkify has created a dump of the data in Amazon S3 storage.\nThis dump currently consists of JSON logs of the user activity and metadata\non the songs."),(0,i.kt)("p",null,"To improve analysis of the data, the data should be transformed into a star\nschema.\nThe stored data should then be stored again on S3 for further usage."),(0,i.kt)("h3",{id:"solution"},"Solution"),(0,i.kt)("p",null,"We read the data from with (Py)Spark and transform it into a star schema.\nFinally we store the results as parquet files from which they can be easily\nprocessed further on."),(0,i.kt)("h3",{id:"getting-started"},"Getting started"),(0,i.kt)("p",null,"A working Python (>= Python 3.6) environment is required."),(0,i.kt)("p",null,"In this enviroment run"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"pip install pyspark\n")),(0,i.kt)("p",null,"or use the provided Anaconda environment"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"conda create -p ./.conda-env --file conda.txt\nconda activate ./.conda-env\n")),(0,i.kt)("p",null,"Then execute the ",(0,i.kt)("inlineCode",{parentName:"p"},"etl.py")," script, which can either be executed in a local\nmode or the remote mode:"),(0,i.kt)("p",null,"Local mode:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# make sure to first unzip the sample data\nbash unzip_data.sh\n\npython etl.py local --help   # list all parameters\npython etl.py local          # runs the script in local mode (with default params)\n")),(0,i.kt)("p",null,"Remote mode:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"python etl.py remote --help  # list all parameters\npython etl.py remote --s3-bucket-target s3a://your-bucket-id\n")),(0,i.kt)("p",null,"When running in remote mode, make sure to enter AWS credentials in the\n",(0,i.kt)("inlineCode",{parentName:"p"},"dl.cfg")," file first."),(0,i.kt)("h2",{id:"sparkify-data-warehouse-with-redshift"},"Sparkify Data Warehouse with Redshift"),(0,i.kt)("p",null,"Sharpen your data warehousing skills and deepen your understanding of data infrastructure. Create cloud-based data warehouses on Amazon Web Services (AWS). Build a data warehouse on AWS and build an ETL pipeline for a database hosted on Redshift. The data is loaded from S3 buckets to staging tables on Redshift and modeled into fact and dimensions tables to perform analytics and obtain meaningful insights."),(0,i.kt)("p",null,"In this lab AWS Redshift is used as a Data Warehouse for a fictional music streaming service, which is called Sparkify."),(0,i.kt)("h3",{id:"problem-1"},"Problem"),(0,i.kt)("p",null,"The scenario that should be solved in this lab is:\nSparkify has gained a lot new users and the song database as well as the recorded song plays have increased over time."),(0,i.kt)("p",null,"Sparkify has created a dump of the data in Amazon S3 storage.\nThis dump currently consists of JSON logs of the user activity and metadata on the songs."),(0,i.kt)("h3",{id:"solution-1"},"Solution"),(0,i.kt)("p",null,"We use AWS Redshift as a data warehouse in order to make the data available to a wider audience.\nThe data will first be loaded from S3 into a staging area in Redshift, where we create two tables that stores the data in a simlar schema as the dumped data on S3."),(0,i.kt)("p",null,"In a second step the data is then transformed into a star schema which is optimized for data analytics queries."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/215310794-262587b0-2c11-448b-8afc-b153f2c98069.png",alt:"database-data-warehousing"})),(0,i.kt)("h3",{id:"getting-started-1"},"Getting started"),(0,i.kt)("p",null,"Make sure to have a AWS Redshift cluster up and running and enter the login details in the ",(0,i.kt)("inlineCode",{parentName:"p"},"dwh.cfg")," file.\nThe cluster must be configured, such that it can be reached from public if the scripts are not executed within the VPC."),(0,i.kt)("p",null,"Then start the pipeline:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Create the tables by running ",(0,i.kt)("inlineCode",{parentName:"li"},"python create_tables.py")," from the terminal."),(0,i.kt)("li",{parentName:"ol"},"Run the ETL pipeline to extract the data from S3 to Redshift and transform/load it into the target tables.")),(0,i.kt)("p",null,"Both scripts log also to stdout, so that we can see what is happening while we create tables or load data into Redshift.\nThe ETL step takes quite some time, so please be patient."),(0,i.kt)("h3",{id:"data-layout"},"Data Layout"),(0,i.kt)("p",null,"The data layout in the Data Warehouse follows the star schema.\nIt consists of one fact table ",(0,i.kt)("inlineCode",{parentName:"p"},"fact_songplay")," and four dimension tables: ",(0,i.kt)("inlineCode",{parentName:"p"},"dim_user"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"dim_song"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"dim_artist")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"dim_time"),"."),(0,i.kt)("p",null,"In a larger cluster I expect analytic queries to be user and song centric, which means that these tables will often be joined.\nAs long as these tables do not grow too much in size it makes sense to replicate them to all nodes to mitigate data transfer across nodes.\nBecause of this tables ",(0,i.kt)("inlineCode",{parentName:"p"},"dim_user")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"dim_song")," have attached ",(0,i.kt)("inlineCode",{parentName:"p"},"diststyle ALL")," in their ",(0,i.kt)("inlineCode",{parentName:"p"},"CREATE TABLE")," statements."),(0,i.kt)("p",null,"Also I expect queries to be mostly interested in the latest events, which is why ",(0,i.kt)("inlineCode",{parentName:"p"},"fact_songplay.start_time")," is the leading column for the sort key.\nThis means that Redshift can ",(0,i.kt)("a",{parentName:"p",href:"https://docs.aws.amazon.com/redshift/latest/dg/c_best-practices-sort-key.html"},"skip entire blocks that fall outside a time range")," in queries that select data based on the time."),(0,i.kt)("p",null,"Since the artist table ",(0,i.kt)("inlineCode",{parentName:"p"},"dim_artist")," is not shared with all nodes in the cluster, opposite to ",(0,i.kt)("inlineCode",{parentName:"p"},"dim_user")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"dim_song"),", the column ",(0,i.kt)("inlineCode",{parentName:"p"},"artist_id")," (",(0,i.kt)("inlineCode",{parentName:"p"},"fact_songplay.artist_id"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"dim_artist.artist_id"),") as been defined as distribution key.\nBecause ",(0,i.kt)("inlineCode",{parentName:"p"},"dim_artist.artist_id")," is defined as sort key it should ",(0,i.kt)("a",{parentName:"p",href:"https://docs.aws.amazon.com/redshift/latest/dg/c_best-practices-sort-key.html"},"enable the query optimizer to choose a sort merge join instead of a slower hash join"),"."),(0,i.kt)("h3",{id:"transformations"},"Transformations"),(0,i.kt)("h4",{id:"dimension-artist"},"Dimension: Artist"),(0,i.kt)("p",null,"For demonstration purposes:\nWhen inserting data into the ",(0,i.kt)("inlineCode",{parentName:"p"},"dim_artist")," table, I check for ",(0,i.kt)("inlineCode",{parentName:"p"},"NULL")," values or empty strings in the column ",(0,i.kt)("inlineCode",{parentName:"p"},"location"),".\nI don't want to have empty values in this column, so I replace the missing value with ",(0,i.kt)("inlineCode",{parentName:"p"},"N/A"),"."),(0,i.kt)("h4",{id:"dimension-time"},"Dimension: Time"),(0,i.kt)("p",null,"As usual various values are extracted from the timestamp, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"hour"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"day"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"week"),", etc."),(0,i.kt)("h2",{id:"sparkify-data-pipeline-with-airflow"},"Sparkify Data Pipeline with Airflow"),(0,i.kt)("p",null,"Sparkify wants to analyze the data they've been collecting on songs and user activity on their new music streaming application. Sparkify has decided that it is time to introduce more automation and monitoring to their data warehouse ETL pipelines and have come to the conclusion that the best tool to achieve this is Apache Airflow."),(0,i.kt)("p",null,"Sparkify has decided that it is time to introduce more automation and monitoring to their data warehouse ETL pipelines and have come to the conclusion that the best tool to achieve this is Apache Airflow."),(0,i.kt)("p",null,"They'd like a data engineer to create high grade data pipelines that are dynamic and built from reusable tasks, can be monitored, and allow easy backfills. They have also noted that the data quality plays a big part when analyses are executed on top the data warehouse and want to run data quality tests against their datasets after the ETL steps have been executed to catch any discrepancies in the datasets."),(0,i.kt)("p",null,"The source data resides in S3 and needs to be processed in Sparkify's data warehouse in Amazon Redshift. The source datasets consist of JSON logs that tell about user activity in the application and JSON metadata about the songs the users listen to."),(0,i.kt)("p",null,"Schedule, automate, and monitor data pipelines using Apache Airflow. Run data quality checks, track data lineage, and work with data pipelines in production."),(0,i.kt)("p",null,"In this milestone, we will build data pipelines using Apache Airflow using custom defined operators to perform tasks such as staging the data, filling the data warehouse, and running checks on the data as the final step."),(0,i.kt)("p",null,"The data stored on S3 buckets is staged and then inserted to fact and dimensional tables on Redshift using Airflow pipelines."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://knowledgetree.notion.site/Building-a-Data-Pipeline-for-Sparkify-Music-Company-Data-Pipelines-with-Airflow-Shared-bc7d6c79c5be426ba75e2cb2501fb663"},"Read this for more information")),(0,i.kt)("p",null,"They'd like a data engineer to create high grade data pipelines that are dynamic and built from reusable tasks, can be monitored, and allow easy backfills. They have also noted that the data quality plays a big part when analyses are executed on top the data warehouse and want to run data quality tests against their datasets after the ETL steps have been executed to catch any discrepancies in the datasets."),(0,i.kt)("p",null,"The source data resides in S3 and needs to be processed in Sparkify's data warehouse in Amazon Redshift. The source datasets consist of JSON logs that tell about user activity in the application and JSON metadata about the songs the users listen to."),(0,i.kt)("p",null,"Schedule, automate, and monitor data pipelines using Apache Airflow. Run data quality checks, track data lineage, and work with data pipelines in production."),(0,i.kt)("p",null,"Task:"),(0,i.kt)("p",null,"Build data pipeline using Apache Airflow using custom defined operators to perform tasks such as staging the data, filling the data warehouse, and running checks on the data as the final step."),(0,i.kt)("p",null,"Process steps:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Upload the Sparkify data to S3 Bucket"),(0,i.kt)("li",{parentName:"ol"},"Update the Bucket and Path information in DAG"),(0,i.kt)("li",{parentName:"ol"},"Add the helpers and operators in airflow plugins directory"),(0,i.kt)("li",{parentName:"ol"},"Add connection: {'connection_id':'aws_default', 'connection_type':'amazon_web_services', 'aws_access_key_id':{AWS_ACCESS_KEY}, 'aws_secret_access_key':{AWS_SECRET_KEY}}"),(0,i.kt)("li",{parentName:"ol"},"Add connection: {'connection_id':'redshift', 'connection_type':'amazon_redshift', 'host':{HOST}, 'port':{PORT}, 'schema':{DATABASE}, 'login':{USER}, 'password':{PASSWORD}}"),(0,i.kt)("li",{parentName:"ol"},"Run the DAG")),(0,i.kt)("p",null,"In this project Airflow is used to coordinate tasks that process large\namounts of data for a fictional music streaming service, which is called\nSparkify."),(0,i.kt)("h3",{id:"problem-2"},"Problem"),(0,i.kt)("p",null,"The scenario that should be solved in this project is:\nSparkify has gained a lot new users and the song database as well as the\nrecorded song plays have increased over time."),(0,i.kt)("p",null,"Sparkify has created a dump of the data in Amazon S3 storage.\nThis dump currently consists of JSON logs of the user activity and metadata\non the songs."),(0,i.kt)("p",null,"To improve analysis of the data, the data should be transformed into a star\nschema.\nThe stored data should then be stored in a AWS Redshift Data Warehouse."),(0,i.kt)("h3",{id:"solution-2"},"Solution"),(0,i.kt)("p",null,"We use Airflow to automatically read data in periodic intervals from S3 and\nwrite them into a staging table in Amazon Redshift."),(0,i.kt)("p",null,"We load both datasets in parallel into the staging area."),(0,i.kt)("p",null,"After that we create fact and dimension tables.\nFirst we create the fact dimension table and in a second step we create all\ndimension tables in parallel."),(0,i.kt)("p",null,"In a last step we run data quality checks on the transformed data."),(0,i.kt)("p",null,"Our DAG looks like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/215310961-59d74f2c-6d75-4af0-9c5f-1814ca037733.png",alt:"project5-dag"})),(0,i.kt)("h3",{id:"getting-started-2"},"Getting started"),(0,i.kt)("p",null,"A working Python (>= Python 3.6) environment is required."),(0,i.kt)("p",null,"In this enviroment run"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"pip install -r requirements.txt\n")),(0,i.kt)("p",null,"or use the provided Anaconda environment"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"conda create -p ./.conda-env python=3.7 --file requirements.txt\nconda activate ./.conda-env\n")),(0,i.kt)("p",null,"Then start Airflow:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"bash run-airflow.sh\n")),(0,i.kt)("p",null,"This will start the Airflow scheduler and webserver in parallel."),(0,i.kt)("p",null,"Make sure to have a AWS Redshift cluster running.\nThe setup requires you to have two credentials stored in your Airflow\ninstance as connections:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Credentials Name"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"aws_credentials"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Credentials for your AWS user. Use fields ",(0,i.kt)("inlineCode",{parentName:"td"},"login")," and ",(0,i.kt)("inlineCode",{parentName:"td"},"password")," and set your ",(0,i.kt)("inlineCode",{parentName:"td"},"access_key")," and ",(0,i.kt)("inlineCode",{parentName:"td"},"secret_access_key")," here.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"redshift"),(0,i.kt)("td",{parentName:"tr",align:"left"},'Choose "Postgres" as the connection type. Enter your AWS Redshift credentials here. Your database name should be stored in the field named "Schema".')))),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/215310782-b43e1286-aacb-497e-aa41-945388fec290.png",alt:"airflow-credentials-1"})),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/215310783-12138d3a-364b-4f71-b18d-8f298013ea81.png",alt:"airflow-credentials-2"})),(0,i.kt)("p",null,"Also make sure that the tables exist on the cluster.\nThe SQL query to create them can be found in the file ",(0,i.kt)("inlineCode",{parentName:"p"},"create_tables.sql"),"."),(0,i.kt)("p",null,"Then go to https://localhost:8080 and enable the DAG ",(0,i.kt)("inlineCode",{parentName:"p"},"udac_project_dag")," to start the process."),(0,i.kt)("h3",{id:"about-the-project"},"About The Project"),(0,i.kt)("p",null,"A startup called Sparkify wants to analyze the data they've been collecting on songs and user activity on their new music streaming application. Sparkify has decided that it is time to introduce more automation and monitoring to their data warehouse ETL pipelines and have come to the conclusion that the best tool to achieve this is Apache Airflow."),(0,i.kt)("p",null,"They'd like a data engineer to create high grade data pipelines that are dynamic and built from reusable tasks, can be monitored, and allow easy backfills. They have also noted that the data quality plays a big part when analyses are executed on top the data warehouse and want to run data quality tests against their datasets after the ETL steps have been executed to catch any discrepancies in the datasets."),(0,i.kt)("p",null,"The source data resides in S3 and needs to be processed in Sparkify's data warehouse in Amazon Redshift. The source datasets consist of JSON logs that tell about user activity in the application and JSON metadata about the songs the users listen to."),(0,i.kt)("h3",{id:"project-description-1"},"Project Description"),(0,i.kt)("p",null,"In this project, we will build data pipelines using Apache Airflow using custom defined operators to perform tasks such as staging the data, filling the data warehouse, and running checks on the data as the final step."),(0,i.kt)("h3",{id:"built-with-1"},"Built With"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"python"),(0,i.kt)("li",{parentName:"ul"},"AWS"),(0,i.kt)("li",{parentName:"ul"},"Apache Airflow")),(0,i.kt)("h3",{id:"dataset-1"},"Dataset"),(0,i.kt)("h4",{id:"song-dataset-1"},"Song Dataset"),(0,i.kt)("p",null,"Songs dataset is a subset of ",(0,i.kt)("a",{parentName:"p",href:"http://millionsongdataset.com/"},"Million Song Dataset"),". Each file in the dataset is in JSON format and contains meta-data about a song and the artist of that song. The dataset is hosted at S3 bucket ",(0,i.kt)("inlineCode",{parentName:"p"},"s3://sparsh-dend/song_data"),"."),(0,i.kt)("p",null,"Sample Record :"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'{"num_songs": 1, "artist_id": "ARJIE2Y1187B994AB7", "artist_latitude": null, "artist_longitude": null, "artist_location": "", "artist_name": "Line Renaud", "song_id": "SOUPIRU12A6D4FA1E1", "title": "Der Kleine Dompfaff", "duration": 152.92036, "year": 0}\n')),(0,i.kt)("h4",{id:"log-dataset-1"},"Log Dataset"),(0,i.kt)("p",null,"Logs dataset is generated by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Interana/eventsim"},"Event Simulator"),". These log files in JSON format simulate activity logs from a music streaming application based on specified configurations. The dataset is hosted at S3 bucket ",(0,i.kt)("inlineCode",{parentName:"p"},"s3://sparsh-dend/log_data"),"."),(0,i.kt)("p",null,"Sample Record :"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'{"artist": null, "auth": "Logged In", "firstName": "Walter", "gender": "M", "itemInSession": 0, "lastName": "Frye", "length": null, "level": "free", "location": "San Francisco-Oakland-Hayward, CA", "method": "GET","page": "Home", "registration": 1540919166796.0, "sessionId": 38, "song": null, "status": 200, "ts": 1541105830796, "userAgent": "\\"Mozilla\\/5.0 (Macintosh; Intel Mac OS X 10_9_4) AppleWebKit\\/537.36 (KHTML, like Gecko) Chrome\\/36.0.1985.143 Safari\\/537.36\\"", "userId": "39"}\n')),(0,i.kt)("h3",{id:"database-schema-design"},"Database Schema Design"),(0,i.kt)("h4",{id:"data-model-erd-1"},"Data Model ERD"),(0,i.kt)("p",null,"The Star Database Schema (Fact and Dimension Schema) is used for data modeling in this ETL pipeline. There is one fact table containing all the metrics (facts) associated to each event (user actions), and four dimensions tables, containing associated information such as user name, artist name, song meta-data etc. This model enables to search the database schema with the minimum number of ",(0,i.kt)("em",{parentName:"p"},"SQL JOIN"),"s possible and enable fast read queries."),(0,i.kt)("p",null,"The data stored on S3 buckets is staged and then inserted to fact and dimensional tables on Redshift. The whole process in orchestrated using Airflow which is set to execute periodically once every hour."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/215310793-1d7b3a80-2001-4885-9ef4-6c1bebc85bcb.png",alt:"database-data-pipeline"})),(0,i.kt)("h3",{id:"apache-airflow-orchestration"},"Apache Airflow Orchestration"),(0,i.kt)("h4",{id:"dag-structure"},"DAG Structure"),(0,i.kt)("p",null,"The DAG parameters are set according to the following :"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The DAG does not have dependencies on past runs"),(0,i.kt)("li",{parentName:"ul"},"DAG has schedule interval set to hourly"),(0,i.kt)("li",{parentName:"ul"},"On failure, the task are retried 3 times"),(0,i.kt)("li",{parentName:"ul"},"Retries happen every 5 minutes"),(0,i.kt)("li",{parentName:"ul"},"Catchup is turned off"),(0,i.kt)("li",{parentName:"ul"},"Email are not sent on retry")),(0,i.kt)("p",null,"The DAG dependency graph is given below."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/215310788-f962236c-a910-499a-8e10-badbf6518d60.png",alt:"dag"})),(0,i.kt)("h4",{id:"operators"},"Operators"),(0,i.kt)("p",null,"Operators create necessary tables, stage the data, transform the data, and run checks on data quality. Connections and Hooks are configured using Airflow's built-in functionalities. All of the operators and task run SQL statements against the Redshift database."),(0,i.kt)("h4",{id:"stage-operator"},"Stage Operator"),(0,i.kt)("p",null,"The stage operator loads any JSON formatted files from S3 to Amazon Redshift. The operator creates and runs a SQL COPY statement based on the parameters provided. The operator's parameters specify where in S3, the file is loaded and what is the target table."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Task to stage JSON data is included in the DAG and uses the RedshiftStage operator"),": There is a task that to stages data from S3 to Redshift (Runs a Redshift copy statement)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Task uses params"),": Instead of running a static SQL statement to stage the data, the task uses parameters to generate the copy statement dynamically. It also contains a templated field that allows it to load timestamped files from S3 based on the execution time and run backfills."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Logging used"),": The operator contains logging in different steps of the execution."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"The database connection is created by using a hook and a connection"),": The SQL statements are executed by using a Airflow hook.")),(0,i.kt)("h4",{id:"fact-and-dimension-operators"},"Fact and Dimension Operators"),(0,i.kt)("p",null,"The dimension and fact operators make use of the SQL helper class to run data transformations. Operators take as input the SQL statement from the helper class and target the database on which to run the query against. A target table is also defined that contains the results of the transformation."),(0,i.kt)("p",null,"Dimension loads are done with the truncate-insert pattern where the target table is emptied before the load. There is a parameter that allows switching between insert modes when loading dimensions. Fact tables are massive so they only allow append type functionality."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Set of tasks using the dimension load operator is in the DAG"),": Dimensions are loaded with on the LoadDimension operator."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"A task using the fact load operator is in the DAG"),": Facts are loaded with on the LoadFact operator."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Both operators use params"),": Instead of running a static SQL statement to stage the data, the task uses parameters to generate the copy statement dynamically."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"The dimension task contains a param to allow switch between append and insert-delete functionality"),": The DAG allows to switch between append-only and delete-load functionality.")),(0,i.kt)("h4",{id:"data-quality-operator"},"Data Quality Operator"),(0,i.kt)("p",null,"The data quality operator is used to run checks on the data itself. The operator's main functionality is to receive one or more SQL based test cases along with the expected results and execute the tests. For each the test, the test result and expected result are checked and if there is no match, the operator raises an exception and the task is retried and fails eventually."),(0,i.kt)("p",null,"For example one test could be a SQL statement that checks if certain column contains NULL values by counting all the rows that have NULL in the column. We do not want to have any NULLs so expected result would be 0 and the test would compare the SQL statement's outcome to the expected result."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"A task using the data quality operator is in the DAG and at least one data quality check is done"),": Data quality check is done with correct operator."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"The operator raises an error if the check fails"),": The DAG either fails or retries n times."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"The operator is parametrized"),": Operator uses params to get the tests and the results, tests are not hard coded to the operator.")),(0,i.kt)("h4",{id:"airflow-ui-views-of-dag-and-plugins"},"Airflow UI views of DAG and plugins"),(0,i.kt)("p",null,"The DAG follows the data flow provided in the instructions, all the tasks have a dependency and DAG begins with a start_execution task and ends with a end_execution task."),(0,i.kt)("h3",{id:"project-structure"},"Project structure"),(0,i.kt)("p",null,"Files in this repository:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"File / Folder"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"dags"),(0,i.kt)("td",{parentName:"tr",align:"center"},"Folder at the root of the project, where DAGs and SubDAGS are stored")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"images"),(0,i.kt)("td",{parentName:"tr",align:"center"},"Folder at the root of the project, where images are stored")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"plugins/helpers"),(0,i.kt)("td",{parentName:"tr",align:"center"},"Contains a SQL helper class for easy querying")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"plugins/operators"),(0,i.kt)("td",{parentName:"tr",align:"center"},"Contains the custom operator to perform the DAG tasks")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"create_tables.sql"),(0,i.kt)("td",{parentName:"tr",align:"center"},"Contains SQL commands to create the necessary tables on Redshift")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"README"),(0,i.kt)("td",{parentName:"tr",align:"center"},"Readme file")))),(0,i.kt)("h3",{id:"getting-started-3"},"Getting Started"),(0,i.kt)("p",null,"Clone the repository into a local machine using"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"git clone https://github.com/vineeths96/Data-Engineering-Nanodegree\n")),(0,i.kt)("h4",{id:"prerequisites"},"Prerequisites"),(0,i.kt)("p",null,"These are the prerequisites to run the program."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"python 3.7"),(0,i.kt)("li",{parentName:"ul"},"AWS account"),(0,i.kt)("li",{parentName:"ul"},"Apache Airflow")),(0,i.kt)("h4",{id:"how-to-run"},"How to run"),(0,i.kt)("p",null,"Follow the steps to extract and load the data into the data model."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Set up Apache Airflow to run in local"),(0,i.kt)("li",{parentName:"ol"},"Navigate to ",(0,i.kt)("inlineCode",{parentName:"li"},"Project 5 Data Pipelines")," folder"),(0,i.kt)("li",{parentName:"ol"},"Set up ",(0,i.kt)("inlineCode",{parentName:"li"},"AWS Connection")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"Redshift Connection")," to Airflow using necessary values"),(0,i.kt)("li",{parentName:"ol"},"In Airflow, turn the DAG execution ON"),(0,i.kt)("li",{parentName:"ol"},"View the Web UI for detailed insights about the operation")),(0,i.kt)("h2",{id:"project-structure-1"},"Project Structure"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"\u251c\u2500\u2500 [ 60K]  01-postgres-datamodel\n\u2502   \u251c\u2500\u2500 [ 12K]  REPORT.md\n\u2502   \u251c\u2500\u2500 [ 384]  dwh.cfg\n\u2502   \u251c\u2500\u2500 [ 47K]  etl.ipynb\n\u2502   \u251c\u2500\u2500 [ 320]  nbs\n\u2502   \u2514\u2500\u2500 [ 256]  src\n\u251c\u2500\u2500 [106K]  02-cassandra-datamodel\n\u2502   \u251c\u2500\u2500 [ 13K]  REPORT.md\n\u2502   \u251c\u2500\u2500 [ 28K]  cassandra-datamodel-ecs.ipynb\n\u2502   \u251c\u2500\u2500 [ 65K]  cassandra-datamodel.ipynb\n\u2502   \u251c\u2500\u2500 [ 185]  cassandra-docker-compose.yml\n\u2502   \u251c\u2500\u2500 [  96]  level1\n\u2502   \u2514\u2500\u2500 [ 256]  level2\n\u251c\u2500\u2500 [ 64K]  03-datalake\n\u2502   \u251c\u2500\u2500 [1.8K]  _EMRJupyterNotebook.md\n\u2502   \u251c\u2500\u2500 [7.6K]  _athena.md\n\u2502   \u251c\u2500\u2500 [6.4K]  _emr.md\n\u2502   \u251c\u2500\u2500 [ 22K]  _notes.md\n\u2502   \u251c\u2500\u2500 [ 460]  ecs-params-spark.yml\n\u2502   \u251c\u2500\u2500 [ 460]  ecs-params.yml\n\u2502   \u251c\u2500\u2500 [ 192]  nbs\n\u2502   \u251c\u2500\u2500 [ 224]  outputs\n\u2502   \u251c\u2500\u2500 [1.2K]  spark-docker-compose.yml\n\u2502   \u251c\u2500\u2500 [  99]  spark.cfg\n\u2502   \u251c\u2500\u2500 [ 17K]  spark_datalake.ipynb\n\u2502   \u251c\u2500\u2500 [4.7K]  spark_etl.py\n\u2502   \u2514\u2500\u2500 [ 640]  src\n\u251c\u2500\u2500 [ 51K]  04-redshift-warehousing\n\u2502   \u251c\u2500\u2500 [ 11K]  _notes.md\n\u2502   \u251c\u2500\u2500 [ 39K]  _report.md\n\u2502   \u251c\u2500\u2500 [ 192]  cfg\n\u2502   \u251c\u2500\u2500 [ 224]  nbs\n\u2502   \u2514\u2500\u2500 [ 448]  src\n\u251c\u2500\u2500 [ 59K]  05-data-pipeline\n\u2502   \u251c\u2500\u2500 [ 55K]  _notes.md\n\u2502   \u251c\u2500\u2500 [ 256]  airflow\n\u2502   \u251c\u2500\u2500 [3.2K]  airflow_pipeline.ipynb\n\u2502   \u251c\u2500\u2500 [ 192]  myLabs\n\u2502   \u2514\u2500\u2500 [  96]  src\n\u251c\u2500\u2500 [ 11K]  IMAGES.md\n\u251c\u2500\u2500 [ 31K]  README.md\n\u2514\u2500\u2500 [1.6M]  data\n    \u251c\u2500\u2500 [  42]  download.sh\n    \u251c\u2500\u2500 [834K]  event_datafile.csv\n    \u251c\u2500\u2500 [834K]  event_datafile_new.csv\n    \u2514\u2500\u2500 [ 456]  log_json_path.json\n\n 2.0M used in 19 directories, 27 files\n")))}h.isMDXComponent=!0}}]);
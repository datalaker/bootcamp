"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[64624],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>u});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=d(a),u=i,m=h["".concat(l,".").concat(u)]||h[u]||p[u]||r;return a?n.createElement(m,o(o({ref:t},c),{},{components:a})):n.createElement(m,o({ref:t},c))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var d=2;d<r;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},86954:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var n=a(87462),i=(a(67294),a(3905));const r={},o="K-Nearest Neighbors",s={unversionedId:"datascience/algorithms/knn",id:"datascience/algorithms/knn",title:"K-Nearest Neighbors",description:"K-Nearest Neighbors, or KNN, is one of the simplest and the most intuitive classical machine learning algorithms. KNN was first proposed by Evelyn Fix and Joseph Lawson Hodges Jr. during a technical analysis produced for USAF in 1951. It was unique at its time as the method proposed is nonparametric: the algorithm does not make any assumptions about the statistical properties of the data. Although the paper wasn\u2019t ever published due to the confidential nature of the work, it laid out the groundwork for the first-ever nonparametric classification method, K-Nearest Neighbors. The beauty of KNN lies in its simplicity, and unlike most other algorithms, KNN does not contain a training phase. Additional data can be incorporated seamlessly as the algorithm is memory-based, easily adapting to any new data. Over seven decades later, KNN still stands as a popular classification algorithm, and innovations are still constantly being proposed surrounding it.",source:"@site/docs/10-datascience/algorithms/knn.md",sourceDirName:"10-datascience/algorithms",slug:"/datascience/algorithms/knn",permalink:"/docs/datascience/algorithms/knn",draft:!1,tags:[],version:"current",lastUpdatedBy:"sparsh",lastUpdatedAt:1681047270,formattedLastUpdatedAt:"Apr 9, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Gradient Boosting",permalink:"/docs/datascience/algorithms/gradient-boosting"},next:{title:"Linear Regression",permalink:"/docs/datascience/algorithms/linear-regression"}},l={},d=[],c={toc:d};function p(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"k-nearest-neighbors"},"K-Nearest Neighbors"),(0,i.kt)("p",null,"K-Nearest Neighbors, or KNN, is one of the simplest and the most intuitive classical machine learning algorithms. KNN was first proposed by Evelyn Fix and Joseph Lawson Hodges Jr. during a technical analysis produced for USAF in 1951. It was unique at its time as the method proposed is nonparametric: the algorithm does not make any assumptions about the statistical properties of the data. Although the paper wasn\u2019t ever published due to the confidential nature of the work, it laid out the groundwork for the first-ever nonparametric classification method, K-Nearest Neighbors. The beauty of KNN lies in its simplicity, and unlike most other algorithms, KNN does not contain a training phase. Additional data can be incorporated seamlessly as the algorithm is memory-based, easily adapting to any new data. Over seven decades later, KNN still stands as a popular classification algorithm, and innovations are still constantly being proposed surrounding it."),(0,i.kt)("p",null,"K-Nearest Neighbors is merely an algorithm concept. Although it was originally proposed for classification tasks, it can also be adapted to regression tasks. One major downfall to KNN is its speed. The time it takes for inference grows significantly as the number of samples increases. The Curse of Dimensionality, as introduced earlier, also weighs down the performance of KNN; as the amount of data features increases, the algorithm struggles to predict samples correctly. However, due to KNN\u2019s easy implementation, the convenience of only having one single hyperparameter, and interoperability, it\u2019s one of the best algorithms to quickly pick up and perform fast predictions on relatively small-sized data."),(0,i.kt)("p",null,"The main intuition behind KNN is to group unlabeled data points with existing, labeled data points and classify data based on their distance to the labeled data points. As unlabeled data points are inputted, the distance between them and other training data points is calculated. Then the closest data point\u2019s label becomes the model prediction for the new data point. We can visualize this with a simple two-dimensional example:"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/230722666-748ded62-5585-41c8-9045-6f16cee3741f.jpeg",alt:"525591_1_En_1_Fig43_HTML"})),(0,i.kt)("p",null,"Assuming that the labeled dataset has two features that are on the same scale, we graph each data point according to its features, with one being on the x-axis and the other on the y-axis. Here, different labels are distinguished with different colors. When a new, unlabeled data point is inputted, we first graph the data point according to its features. Then we calculate the distance from the new data point to each and every other labeled data point. Once we obtain a list of distances associated with each point in the dataset, the list is sorted ascendingly, and the first K elements are picked. K is a hypermeter that can be adjusted to improve performance. Finally, we perform a majority voting on the labels of the points to determine the final prediction. KNN takes advantage of the fact that data points with the same label most likely contain similar values of its features. This idea can be further extended into higher dimensions or data with more than two features."))}p.isMDXComponent=!0}}]);
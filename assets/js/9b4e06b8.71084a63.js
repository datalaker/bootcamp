"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[24832],{3905:(e,a,t)=>{t.d(a,{Zo:()=>d,kt:()=>m});var n=t(67294);function i(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function r(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?r(Object(t),!0).forEach((function(a){i(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function l(e,a){if(null==e)return{};var t,n,i=function(e,a){if(null==e)return{};var t,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||(i[t]=e[t]);return i}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var o=n.createContext({}),c=function(e){var a=n.useContext(o),t=a;return e&&(t="function"==typeof e?e(a):s(s({},a),e)),t},d=function(e){var a=c(e.components);return n.createElement(o.Provider,{value:a},e.children)},p={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},u=n.forwardRef((function(e,a){var t=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=c(t),m=i,h=u["".concat(o,".").concat(m)]||u[m]||p[m]||r;return t?n.createElement(h,s(s({ref:a},d),{},{components:t})):n.createElement(h,s({ref:a},d))}));function m(e,a){var t=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var r=t.length,s=new Array(r);s[0]=u;var l={};for(var o in a)hasOwnProperty.call(a,o)&&(l[o]=a[o]);l.originalType=e,l.mdxType="string"==typeof e?e:i,s[1]=l;for(var c=2;c<r;c++)s[c]=t[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}u.displayName="MDXCreateElement"},33015:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>o,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var n=t(87462),i=(t(67294),t(3905));const r={},s="Create a Data Model for Online Shopping Carts",l={unversionedId:"data-modeling/lab-cassandra-shopping-cart-data-model/README",id:"data-modeling/lab-cassandra-shopping-cart-data-model/README",title:"Create a Data Model for Online Shopping Carts",description:"Conceptual Data Model",source:"@site/docs/04-data-modeling/lab-cassandra-shopping-cart-data-model/README.md",sourceDirName:"04-data-modeling/lab-cassandra-shopping-cart-data-model",slug:"/data-modeling/lab-cassandra-shopping-cart-data-model/",permalink:"/docs/data-modeling/lab-cassandra-shopping-cart-data-model/",draft:!1,tags:[],version:"current",lastUpdatedBy:"sparsh",lastUpdatedAt:1681047270,formattedLastUpdatedAt:"Apr 9, 2023",frontMatter:{}},o={},c=[{value:"Conceptual Data Model",id:"conceptual-data-model",level:2},{value:"Application workflow",id:"application-workflow",level:2},{value:"Logical Data model",id:"logical-data-model",level:2},{value:"Physical Data Model",id:"physical-data-model",level:2},{value:"Hands-on",id:"hands-on",level:2},{value:"Create Keyspace",id:"create-keyspace",level:3},{value:"Create Tables",id:"create-tables",level:3},{value:"Populate tables",id:"populate-tables",level:3},{value:"Design query Q1",id:"design-query-q1",level:3},{value:"Design query Q2",id:"design-query-q2",level:3},{value:"Design query Q3",id:"design-query-q3",level:3},{value:"Design query Q4",id:"design-query-q4",level:3},{value:"Design query Q5",id:"design-query-q5",level:3},{value:"Design query Q6",id:"design-query-q6",level:3},{value:"Design query Q7",id:"design-query-q7",level:3}],d={toc:c};function p(e){let{components:a,...t}=e;return(0,i.kt)("wrapper",(0,n.Z)({},d,t,{components:a,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"create-a-data-model-for-online-shopping-carts"},"Create a Data Model for Online Shopping Carts"),(0,i.kt)("h2",{id:"conceptual-data-model"},"Conceptual Data Model"),(0,i.kt)("p",null,"A conceptual data model is designed with the goal of understanding data in a particular domain. In this example, the model is captured using an Entity-Relationship Diagram (ERD) that documents entity types, relationship types, attribute types, and cardinality and key constraints."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/214248084-c55a2e87-7b08-437c-bee7-8beb025fa702.png",alt:null})),(0,i.kt)("p",null,"The conceptual data model for shopping cart data features users, items and shopping carts. A user has a unique id and may have other attributes like email. An item has a unique id, name, description and price. A shopping cart is uniquely identified by an id and can be either an active shopping cart or a saved shopping cart. Other shopping cart attribute types include a name and subtotal. The latter is a derived attribute type whose value is computed based on prices and quantities of all items in a cart. In general, a derived attribute value can be stored in a database or dynamically computed by an application. While a user can create many shopping carts, each cart must belong to exactly one user. At any time, a user can have at most one active shopping cart and many saved carts. Finally, a shopping cart can have many items and a catalog item can be added to many carts. An item entry in a cart is further described by a timestamp and desired quantity."),(0,i.kt)("h2",{id:"application-workflow"},"Application workflow"),(0,i.kt)("p",null,"An application workflow is designed with the goal of understanding data access patterns for a data-driven application. Its visual representation consists of application tasks, dependencies among tasks, and data access patterns. Ideally, each data access pattern should specify what attributes to search for, search on, order by, or do aggregation on."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/214248072-2d8c7da1-d000-4042-a778-cc7d28fbb2e4.png",alt:null})),(0,i.kt)("p",null,"The application workflow has six tasks, of which three tasks are possible entry-point tasks. Based on this workflow, an application should be able to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"show an active shopping cart of a user, which requires Q1;"),(0,i.kt)("li",{parentName:"ul"},"search for items by id or name, which requires Q2 and Q3, respectively;"),(0,i.kt)("li",{parentName:"ul"},"show all shopping carts of a user, which requires Q4;"),(0,i.kt)("li",{parentName:"ul"},"display items in a shopping cart, which requires Q5;"),(0,i.kt)("li",{parentName:"ul"},"add an item into an active shopping cart, which requires U1;"),(0,i.kt)("li",{parentName:"ul"},"designate a cart to be an active cart, which requires U2.")),(0,i.kt)("p",null,"All in all, there are seven data access patterns for a database to support. While Q1, Q2, Q3, Q4 and Q5 are needed to query data, U1 and U2 are intended to update data. In this example, updates are especially interesting because they require updating multiple rows and may involve race conditions."),(0,i.kt)("h2",{id:"logical-data-model"},"Logical Data model"),(0,i.kt)("p",null,"A logical data model results from a conceptual data model by organizing data into Cassandra-specific data structures based on data access patterns identified by an application workflow. Logical data models can be conveniently captured and visualized using Chebotko Diagrams that can feature tables, materialized views, indexes and so forth."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/214248090-d10a31b1-3c1c-4a60-942d-43d7bdbf53f6.png",alt:null})),(0,i.kt)("p",null,"The logical data model for shopping cart data is represented by the shown Chebotko Diagram. Table active_carts_by_user is designed to support data access pattern Q1. It has single-row partitions since each user can only have one active shopping cart at any time. Table items_by_id is designed to support data access pattern Q2. Similarly, it is a table with single-row partitions and a simple primary key. The remaining three tables have multi-row partitions and compound primary keys that consist of both partition and clustering keys. Table items_by_name enables data access pattern Q3. To retrieve all items with a given name, at most one partition needs to be accessed. Next, table all_carts_by_user is designed to support data access pattern Q4. It features one multi-row partition per user, where each row represents a different shopping cart. Rows within each partition are ordered using cart names and cart ids. Column user_email is a static column as it describes a user who is uniquely identified by the table partition key. Again, only one partition in this table needs to be accessed to answer Q4. Finally, table items_by_cart covers data access pattern Q5. In this table, each partition corresponds to a shopping cart and each row represents an item. Column subtotal is a static column and is a descriptor of a shopping cart. Once again, this very efficient design requires retrieving only one partition to satisfy Q5."),(0,i.kt)("p",null,"Note that, in this example, updates U1 and U2 do not directly affect the table design process. The diagram simply documents which tables need to be accessed to satisfy these data access patterns."),(0,i.kt)("h2",{id:"physical-data-model"},"Physical Data Model"),(0,i.kt)("p",null,"A physical data model is directly derived from a logical data model by analyzing and optimizing for performance. The most common type of analysis is identifying potentially large partitions. Some common optimization techniques include splitting and merging partitions, data indexing, data aggregation and concurrent data access optimizations."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/214248106-436b6daf-a395-4ee8-91de-b51afeccf75a.png",alt:null})),(0,i.kt)("p",null,"The physical data model for shopping cart data is visualized using the Chebotko Diagram. This time, all table columns have associated data types. It should be evident that none of the tables can have very large partitions. Otherwise, some reasonable limits can be enforced by an application, such as at most 100 shopping carts per user, at most 1000 items per cart and at most 10000 items with the same name. The first optimization that this physical data model implements is the elimination of table active_carts_by_user completely and renaming of table all_carts_by_user to simply carts_by_user. The huge advantage of the new design is that U2 becomes much simpler and more efficient to implement because this data access pattern no longer needs to update rows in two tables. In fact, U2 only needs to update two rows in the same partition of table carts_by_user, which can be done efficiently using a batch and a lightweight transaction (see the Skill Building section for a concrete example). The minor disadvantage is that Q1 is not fully supported by table carts_by_user. An application has to retrieve all carts that belong to a user as in Q4 and further scan the result to find an active cart. Assuming that an average user only has a few carts, this should not be a problem at all. Alternatively, it is also possible to create a secondary index on column cart_is_active to fully support Q1 in Cassandra. But using an index to find one row in a partition with only a few rows is likely to be less efficient than simply scanning those few rows (and avoiding index maintenance costs, too). The second and last optimization is the replacement of table items_by_name with a materialized view items_by_name. This is done for convenience rather than efficiency. Our final blueprint is ready to be instantiated in Cassandra."),(0,i.kt)("h2",{id:"hands-on"},"Hands-on"),(0,i.kt)("p",null,"In this lab, you will:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Create tables for a shopping cart data use case"),(0,i.kt)("li",{parentName:"ul"},"Populate tables with sample shopping cart data"),(0,i.kt)("li",{parentName:"ul"},"Design and execute CQL queries over shopping cart data")),(0,i.kt)("h3",{id:"create-keyspace"},"Create Keyspace"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE KEYSPACE shopping_cart_data\nWITH replication = {\n  'class': 'SimpleStrategy', \n  'replication_factor': 1 }; \n\nUSE shopping_cart_data;\n")),(0,i.kt)("h3",{id:"create-tables"},"Create Tables"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE IF NOT EXISTS carts_by_user (\n  user_id TEXT,\n  cart_name TEXT,\n  cart_id UUID,\n  cart_is_active BOOLEAN,\n  user_email TEXT STATIC,\n  PRIMARY KEY ((user_id),cart_name,cart_id)\n);\n\nCREATE TABLE IF NOT EXISTS items_by_id (\n  id TEXT,\n  name TEXT,\n  description TEXT,\n  price DECIMAL,\n  PRIMARY KEY ((id))\n);\n\nCREATE MATERIALIZED VIEW IF NOT EXISTS items_by_name \n  AS \n    SELECT * FROM items_by_id\n    WHERE name IS NOT NULL \n      AND id IS NOT NULL\n  PRIMARY KEY ((name), id);\n\nCREATE TABLE IF NOT EXISTS items_by_cart (\n  cart_id UUID,\n  timestamp TIMESTAMP,\n  item_id TEXT,\n  item_name TEXT,\n  item_description TEXT,\n  item_price DECIMAL,\n  quantity INT,\n  cart_subtotal DECIMAL STATIC,\n  PRIMARY KEY ((cart_id),timestamp,item_id)\n) WITH CLUSTERING ORDER BY (timestamp DESC, item_id ASC);\n\nDESCRIBE TABLES;\n")),(0,i.kt)("h3",{id:"populate-tables"},"Populate tables"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"SOURCE 'shopping_cart_data.cql'\n")),(0,i.kt)("p",null,"Retrieve some rows from tables:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT user_id, cart_name, \n       cart_id, cart_is_active\nFROM carts_by_user;        \nSELECT * FROM items_by_id;\nSELECT * FROM items_by_name;                    \nSELECT cart_id, timestamp, item_id \nFROM items_by_cart; \nSELECT cart_id, item_id, item_price, \n       quantity, cart_subtotal \nFROM items_by_cart; \n")),(0,i.kt)("h3",{id:"design-query-q1"},"Design query Q1"),(0,i.kt)("p",null,"Find id and name of an active shopping cart that belongs to user jen:"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Show me the Answer! "),"-- Retrieve all carts for jen -- and scan the result set -- within an application -- to find an active cart. SELECT user_id, cart_name, cart_id, cart_is_active FROM carts_by_user WHERE user_id = 'jen';"),(0,i.kt)("br",null),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Show me the Answer! "),"-- Retrieve all carts for jen -- and scan the result set -- within Cassandra -- to find an active cart. -- Note that this is a rare case of -- scanning within a small partition -- when ALLOW FILTERING -- might be acceptable. SELECT user_id, cart_name, cart_id, cart_is_active FROM carts_by_user WHERE user_id = 'jen' AND cart_is_active = true ALLOW FILTERING;"),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"design-query-q2"},"Design query Q2"),(0,i.kt)("p",null,"Find ids and names of all shopping carts that belong to user jen; order by cart name (asc):"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Show me the Answer! "),"SELECT user_id, cart_name, cart_id, cart_is_active FROM carts_by_user WHERE user_id = 'jen';"),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"design-query-q3"},"Design query Q3"),(0,i.kt)("p",null,"Save an active shopping cart with name My Birthday and id 4e66baf8-f3ad-4c3b-9151-52be4574f2de, and designate a different cart with name Gifts for Mom and id 19925cc1-4f8b-4a44-b893-2a49a8434fc8 to be a new active shopping cart for user jen:"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Show me the Answer! "),"BEGIN BATCH UPDATE carts_by_user SET cart_is_active = false WHERE user_id = 'jen' AND cart_name = 'My Birthday' AND cart_id = 4e66baf8-f3ad-4c3b-9151-52be4574f2de IF cart_is_active = true; UPDATE carts_by_user SET cart_is_active = true WHERE user_id = 'jen' AND cart_name = 'Gifts for Mom' AND cart_id = 19925cc1-4f8b-4a44-b893-2a49a8434fc8; APPLY BATCH;",(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"SELECT user_id, cart_name, \n      cart_id, cart_is_active\nFROM carts_by_user\nWHERE user_id = 'jen';\n"))),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"design-query-q4"},"Design query Q4"),(0,i.kt)("p",null,"Find all information about an item with id Box2:"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Show me the Answer! "),"SELECT * FROM items_by_id WHERE id = 'Box2';"),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"design-query-q5"},"Design query Q5"),(0,i.kt)("p",null,"Find all information about items with name Chocolate Cake:"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Show me the Answer! "),"SELECT * FROM items_by_name WHERE name = 'Chocolate Cake';"),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"design-query-q6"},"Design query Q6"),(0,i.kt)("p",null,"Find all items and their subtotal for a cart with id 19925cc1-4f8b-4a44-b893-2a49a8434fc8; order items by timestamp (desc):"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Show me the Answer! "),"SELECT timestamp, item_id, item_price, quantity, cart_subtotal FROM items_by_cart WHERE cart_id = 19925cc1-4f8b-4a44-b893-2a49a8434fc8;"),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"design-query-q7"},"Design query Q7"),(0,i.kt)("p",null,"Add item Box2 into active cart 19925cc1-4f8b-4a44-b893-2a49a8434fc8 and update the cart subtotal to 111.50:"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Show me the Answer! "),"BEGIN BATCH INSERT INTO items_by_cart ( cart_id, timestamp, item_id, item_name, item_description, item_price, quantity) VALUES ( 19925cc1-4f8b-4a44-b893-2a49a8434fc8, TOTIMESTAMP(NOW()), 'Box2', 'Chocolates', '25 gourmet chocolates from our collection', 60.00, 1); UPDATE items_by_cart SET cart_subtotal = 111.50 WHERE cart_id = 19925cc1-4f8b-4a44-b893-2a49a8434fc8 IF cart_subtotal = 51.50; APPLY BATCH;",(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"SELECT timestamp, item_id, item_price, \n      quantity, cart_subtotal \nFROM items_by_cart\nWHERE cart_id = 19925cc1-4f8b-4a44-b893-2a49a8434fc8; \n"))),(0,i.kt)("br",null))}p.isMDXComponent=!0}}]);
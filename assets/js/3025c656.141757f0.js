"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[74332],{3905:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>d});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},h=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),u=p(a),d=r,m=u["".concat(l,".").concat(d)]||u[d]||c[d]||o;return a?n.createElement(m,i(i({ref:t},h),{},{components:a})):n.createElement(m,i({ref:t},h))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},9056:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=a(87462),r=(a(67294),a(3905));const o={},i="Lab: Spark Optimizations",s={unversionedId:"foundations/language/pyspark/lab-spark-optimizations-2/README",id:"foundations/language/pyspark/lab-spark-optimizations-2/README",title:"Lab: Spark Optimizations",description:"Performance tuning\xa0in\xa0Apache\xa0Spark\xa0plays an instrumental role in running efficient big data workloads. More\xa0often than not, the optimization techniques employed to prevent the shuffling and skewing of data drastically improve performance. In this lab, we will learn about the Spark optimization techniques directly related to\xa0Spark Core\xa0that help prevent the shuffling and skewing of data.",source:"@site/docs/01-foundations/language/pyspark/lab-spark-optimizations-2/README.md",sourceDirName:"01-foundations/language/pyspark/lab-spark-optimizations-2",slug:"/foundations/language/pyspark/lab-spark-optimizations-2/",permalink:"/docs/foundations/language/pyspark/lab-spark-optimizations-2/",draft:!1,tags:[],version:"current",lastUpdatedBy:"sparsh",lastUpdatedAt:1681539985,formattedLastUpdatedAt:"Apr 15, 2023",frontMatter:{},sidebar:"docs",previous:{title:"Lab: Connect AWS to PySpark and build an ETL pipeline",permalink:"/docs/processing/databricks/lab-databricks-pyspark-s3/"},next:{title:"Lab: Spark Optimizations for Analytics Workloads",permalink:"/docs/foundations/language/pyspark/lab-spark-optimizations/"}},l={},p=[{value:"Learning about broadcast joins",id:"learning-about-broadcast-joins",level:2},{value:"Learning about Apache Arrow in Pandas",id:"learning-about-apache-arrow-in-pandas",level:2},{value:"Understanding shuffle partitions",id:"understanding-shuffle-partitions",level:2},{value:"Understanding caching in Spark",id:"understanding-caching-in-spark",level:2},{value:"Learning about AQE",id:"learning-about-aqe",level:2},{value:"Dynamically coalescing shuffle partitions",id:"dynamically-coalescing-shuffle-partitions",level:3},{value:"Dynamically switching join strategies",id:"dynamically-switching-join-strategies",level:3},{value:"Dynamically optimizing skew joins",id:"dynamically-optimizing-skew-joins",level:3},{value:"Conclusion",id:"conclusion",level:2}],h={toc:p};function c(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"lab-spark-optimizations"},"Lab: Spark Optimizations"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Performance tuning"),"\xa0in\xa0",(0,r.kt)("strong",{parentName:"p"},"Apache"),"\xa0",(0,r.kt)("strong",{parentName:"p"},"Spark"),"\xa0plays an instrumental role in running efficient big data workloads. More\xa0often than not, the optimization techniques employed to prevent the shuffling and skewing of data drastically improve performance. In this lab, we will learn about the Spark optimization techniques directly related to\xa0",(0,r.kt)("strong",{parentName:"p"},"Spark Core"),"\xa0that help prevent the shuffling and skewing of data."),(0,r.kt)("p",null,"We will begin by learning about broadcast joins and how they are different from traditional joins in Spark. Next, we will learn about\xa0",(0,r.kt)("strong",{parentName:"p"},"Apache"),"\xa0",(0,r.kt)("strong",{parentName:"p"},"Arrow"),", its integration with the\xa0",(0,r.kt)("strong",{parentName:"p"},"Python"),"\xa0",(0,r.kt)("strong",{parentName:"p"},"pandas"),"\xa0project, and how it improves the performance of Pandas code in\xa0",(0,r.kt)("strong",{parentName:"p"},"Databricks"),". We will also learn about shuffle partitions, Spark caching, and\xa0",(0,r.kt)("strong",{parentName:"p"},"adaptive query execution"),"\xa0(",(0,r.kt)("strong",{parentName:"p"},"AQE"),"). Shuffle partitions can often become performance bottlenecks, and it is important that we learn how to tune them. Spark caching is another popular optimization technique that helps to speed up queries on the same data without having to re-read it from the source. Last but not least, AQE helps to automatically optimize data engineering workloads. The topics covered in this lab are as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Learning about broadcast joins"),(0,r.kt)("li",{parentName:"ul"},"Learning about Apache Arrow in Pandas"),(0,r.kt)("li",{parentName:"ul"},"Understanding shuffle partitions"),(0,r.kt)("li",{parentName:"ul"},"Understanding caching in Spark"),(0,r.kt)("li",{parentName:"ul"},"Learning about AQE")),(0,r.kt)("h2",{id:"learning-about-broadcast-joins"},"Learning about broadcast joins"),(0,r.kt)("p",null,"In\xa0",(0,r.kt)("strong",{parentName:"p"},"ETL"),"\xa0operations, we\xa0need to perform join operations between new data and lookup tables or historical tables. In such scenarios, a join operation is performed between a large DataFrame (millions of records) and a small DataFrame (hundreds of records). A standard join between a large and small DataFrame incurs a shuffle between the worker nodes of the cluster. This happens because all the matching data needs to be shuffled to every node of the cluster. While this process is computationally expensive, it also leads to performance bottlenecks\xa0due to network overheads on account of shuffling. Here,\xa0",(0,r.kt)("strong",{parentName:"p"},"broadcast joins"),"\xa0come to the rescue! With the help of broadcast joins, Spark duplicates the smaller DataFrame on every node of the cluster, thereby avoiding the cost of shuffling the large DataFrame."),(0,r.kt)("p",null,"We can better understand the difference between a standard join and a broadcast join with the help of the following diagram. In the case of a standard join, the partitions of both the DataFrames need to shuffle across worker nodes or executors so that matching records based on the join\xa0condition can be joined. In the case of a broadcast join, Spark sends a copy of the smaller\xa0DataFrame to each node or executor so that it can be joined with the respective partition of the larger DataFrame."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/218774587-90b9c572-0866-404b-b75b-e864cd852325.jpeg",alt:"B17782_07_01"})),(0,r.kt)("p",null,"In this lab, we will go through a\xa0worked-out example to better understand the performance comparisons of both of these joins."),(0,r.kt)("p",null,"The catch here is that broadcast joins are not suitable for every join scenario, and there is no set limit on DataFrame size so as to define the smaller DataFrame. But as a best practice, DataFrames sized between 10 MB and 50 MB are usually broadcast. Spark also performs broadcast joins implicitly. This behavior is controlled with the help of the Spark configuration,\xa0",(0,r.kt)("strong",{parentName:"p"},"spark.sql.autoBroadcastJoinThreshold"),". The default threshold is 10 MB for the configuration. To disable the configuration, we can set it to\xa0",(0,r.kt)("strong",{parentName:"p"},"-1"),"."),(0,r.kt)("h2",{id:"learning-about-apache-arrow-in-pandas"},"Learning about Apache Arrow in Pandas"),(0,r.kt)("p",null,"Apache Arrow\xa0is an in-memory columnar data format that helps to efficiently store data between\xa0clustered\xa0",(0,r.kt)("strong",{parentName:"p"},"Java Virtual Machines"),"\xa0(",(0,r.kt)("strong",{parentName:"p"},"JVMs"),") and Python processes. This is highly beneficial for data scientists working with\xa0Pandas and\xa0",(0,r.kt)("strong",{parentName:"p"},"NumPy"),"\xa0in Databricks. Apache Arrow does not produce different results in terms of the data. It is helpful when we are converting Spark DataFrames to Pandas DataFrames, and vice versa. Let's try to better understand the utility of Apache Arrow with an analogy."),(0,r.kt)("p",null,"Let's say you were traveling to Europe before the establishment of the\xa0",(0,r.kt)("strong",{parentName:"p"},"European Union"),"\xa0(",(0,r.kt)("strong",{parentName:"p"},"EU"),"). To visit 10 countries in 7 days, you would have has to spend some time at every border for passport control, and money would have always been lost due to currency exchange. Similarly, without using Apache Arrow, inefficiencies exist due to serialization and deserialization processes wasting memory and CPU resources (such as converting a Spark DataFrame to a Pandas DataFrame)."),(0,r.kt)("p",null,"But using Apache\xa0Arrow is like traveling to Europe after the establishment of the EU. This means no more waiting at the borders, and the same currency being used everywhere. Therefore, Apache Arrow allows us to use the same in-memory data format for different frameworks and file formats. This highly optimizes data conversions between Spark and Pandas. In Databricks, Apache Arrow is available as an optimization when converting a\xa0",(0,r.kt)("strong",{parentName:"p"},"PySpark"),"\xa0DataFrame to a Pandas DataFrame with the\xa0",(0,r.kt)("strong",{parentName:"p"},"toPandas()"),"\xa0function, and when converting a Pandas DataFrame to a PySpark DataFrame using the\xa0",(0,r.kt)("strong",{parentName:"p"},"createDataFrame()"),"\xa0function."),(0,r.kt)("p",null,"A point to note here is that even though we are enabling Apache Arrow, working with Pandas still leads to data getting collected on the driver node using the\xa0",(0,r.kt)("strong",{parentName:"p"},"toPandas()"),"\xa0function. Therefore, it should only be used on a small subset of data."),(0,r.kt)("h2",{id:"understanding-shuffle-partitions"},"Understanding shuffle partitions"),(0,r.kt)("p",null,"Every time Spark performs a\xa0wide transformation or aggregations, shuffling of data across the nodes occurs. And during these shuffle operations, Spark, by default, changes the partitions of the DataFrame. For example, when creating a DataFrame, it may have 10 partitions, but as soon as the shuffle occurs, Spark may change the partitions of the DataFrame to 200. These are what we call the shuffle partitions."),(0,r.kt)("p",null,"This is a default behavior in Spark, but it can be altered to improve the performance of Spark jobs. We can also confirm the default behavior by running the following line of code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"spark.conf.get('spark.sql.shuffle.partitions')\n")),(0,r.kt)("p",null,"This returns the output of\xa0",(0,r.kt)("strong",{parentName:"p"},"200"),". This means that Spark will change the shuffle partitions to\xa0",(0,r.kt)("strong",{parentName:"p"},"200"),"\xa0by default. To alter this configuration, we can run the following code, which configures the shuffle partitions to\xa0",(0,r.kt)("strong",{parentName:"p"},"8"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"spark.conf.set('spark.sql.shuffle.partitions',8)\n")),(0,r.kt)("p",null,"You may be wondering why we set the\xa0",(0,r.kt)("strong",{parentName:"p"},"spark.sql.shuffle.partitions"),"\xa0configuration to\xa0",(0,r.kt)("strong",{parentName:"p"},"8"),". This is\xa0because we have eight cores in the cluster we are using. And having the same number of shuffle partitions ensures that during the shuffling process, we will have all the cores' clusters processing the same number of partitions at a time."),(0,r.kt)("h2",{id:"understanding-caching-in-spark"},"Understanding caching in Spark"),(0,r.kt)("p",null,"Every time we perform\xa0an action on a Spark DataFrame, Spark has to re-read the data from the source, run jobs, and provide an output as the result. This may not be a performance bottleneck when reading data for the first time, but if a certain DataFrame needs to be queried repeatedly, Spark will have to re-compute it every time. In such scenarios, Spark caching proves to be highly useful. Spark\xa0",(0,r.kt)("em",{parentName:"p"},"caching"),"\xa0means that we store data in the cluster's memory. As we already know, Spark has memory divided for cached DataFrames and performing operations. Every time a DataFrame is cached in memory, it is stored in the cluster's memory, and Spark does not have to re-read it from the source in order to perform computations on the same DataFrame."),(0,r.kt)("p",null,"NOTE"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Spark caching is a transformation and therefore it is evaluated\xa0",(0,r.kt)("em",{parentName:"p"},"lazily"),". In order to enforce a cache on a DataFrame, we need to call an\xa0",(0,r.kt)("em",{parentName:"p"},"action"),".")),(0,r.kt)("p",null,"Now, you may be wondering how this is different from\xa0",(0,r.kt)("strong",{parentName:"p"},"Delta caching"),". The following table illustrates the differences between Delta caching\xa0and\xa0Spark caching:"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/218777857-8164b86a-40e7-4903-bec7-b248950c8337.jpeg",alt:"B17782_07_02a"}),"\n",(0,r.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/218777543-caab7170-069d-45fc-82dc-17f237f019d1.jpeg",alt:"B17782_07_02b"})),(0,r.kt)("p",null,"Another point to\xa0note is that when a Databricks cluster is terminated, the cache is also lost. In this lab, we will go through a worked-out example to better understand Spark caching in Databricks."),(0,r.kt)("h2",{id:"learning-about-aqe"},"Learning about AQE"),(0,r.kt)("p",null,"We already know\xa0how Spark works under the hood. Whenever we execute transformations, Spark prepares a plan, and as soon as an action is called, it performs those transformations. Now, it's time to expand that knowledge. Let's dive deeper into Spark's query execution mechanism."),(0,r.kt)("p",null,"Every time a query is executed by Spark, it is done with the help of the following four plans:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parsed Logical Plan"),": Spark\xa0prepares a\xa0",(0,r.kt)("em",{parentName:"li"},"Parsed Logical Plan"),", where it checks the metadata (table name, column names, and more) to confirm whether the respective entities exist or not."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Analyzed Logical Plan"),": Spark accepts the Parsed Logical Plan and converts it into what is called the\xa0",(0,r.kt)("em",{parentName:"li"},"Analyzed Logical Plan"),". This is\xa0then sent to Spark's catalyst optimizer, which is an advanced query optimizer for Spark."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Optimized Logical Plan"),": The catalyst optimizer applies further optimizations and comes up with the final logical plan, called\xa0the\xa0",(0,r.kt)("em",{parentName:"li"},"Optimized Logical Plan"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Physical Plan"),": The\xa0",(0,r.kt)("em",{parentName:"li"},"Physical Plan"),"\xa0specifies\xa0how the Optimized Logical Plan is going to be executed on the cluster.")),(0,r.kt)("p",null,"Apart from the catalyst optimizer, there\xa0is another framework in Spark called the\xa0",(0,r.kt)("strong",{parentName:"p"},"cost-based optimizer"),"\xa0(",(0,r.kt)("strong",{parentName:"p"},"CBO"),"). The CBO collects statistics on data, such as the number of distinct values, row counts, null values, and more, to help Spark come up with a better Physical Plan. AQE is another optimization technique that speeds up query execution based on runtime statistics. It does this with the help of the following three features:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Dynamically coalescing shuffle partitions")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Dynamically switching join strategies")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Dynamically optimizing skew joins"))),(0,r.kt)("p",null,"Let's discuss these in detail."),(0,r.kt)("h3",{id:"dynamically-coalescing-shuffle-partitions"},"Dynamically coalescing shuffle partitions"),(0,r.kt)("p",null,"When dealing\xa0with very large datasets, shuffle has a huge impact on performance. It is an expensive operation that requires data to be moved across nodes so that it can be re-distributed as required by the downstream operations. But two types of issues can occur:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If the number of partitions is less, then their size will be larger, and this can lead to data spillage during the shuffle. This can slow down Spark jobs."),(0,r.kt)("li",{parentName:"ul"},"If the number of partitions is more, then there could be a chance that the partitions would be small in size, leading to a greater number of tasks. This can put more burden on Spark's task scheduler.")),(0,r.kt)("p",null,"To solve these problems, we can set a relatively large number of shuffle partitions and then coalesce any adjacent small partitions at runtime. This can be achieved with the help of AQE, as it automatically coalesces small partitions at runtime."),(0,r.kt)("h3",{id:"dynamically-switching-join-strategies"},"Dynamically switching join strategies"),(0,r.kt)("p",null,"With the help\xa0of AQE, Spark can switch join strategies at runtime if they are found to be inefficient. Spark supports various join strategies but usually, the\xa0",(0,r.kt)("em",{parentName:"p"},"broadcast hash join"),"\xa0(also called the\xa0",(0,r.kt)("em",{parentName:"p"},"broadcast join"),") is often considered to be the most performant if one side of the join is small enough to fit in the memory of every node."),(0,r.kt)("h3",{id:"dynamically-optimizing-skew-joins"},"Dynamically optimizing skew joins"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Data skew"),"\xa0occurs\xa0when data is unevenly distributed across the partitions of the DataFrame. It has the potential to downgrade query performance. With the help of AQE, Spark can automatically detect data skew while joins are created. After detection, it splits the larger of those partitions into smaller sub-partitions that are joined to the corresponding partition on the other side of the join. This ensures that the Spark job does not get stuck due to a single enormously large partition."),(0,r.kt)("p",null,"In this recipe, we will go through a worked-out example to learn how AQE actually works in Databricks."),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"In this lab, we learned about several optimization techniques concerning Spark Core. We started off by learning about broadcast joins and how they are more performant than a standard join. Then, we learned about the advantages of using Apache Arrow with Pandas. Next, we learned about shuffle partitions and Spark caching."),(0,r.kt)("p",null,"Finally, we learned about AQE and how it helps to speed up queries during runtime. All these optimization techniques are highly useful for tuning big data workloads in Databricks."))}c.isMDXComponent=!0}}]);
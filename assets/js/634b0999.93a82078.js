"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[61253],{3905:(t,e,a)=>{a.d(e,{Zo:()=>s,kt:()=>g});var n=a(67294);function l(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function r(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?r(Object(a),!0).forEach((function(e){l(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function o(t,e){if(null==t)return{};var a,n,l=function(t,e){if(null==t)return{};var a,n,l={},r=Object.keys(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||(l[a]=t[a]);return l}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(l[a]=t[a])}return l}var m=n.createContext({}),d=function(t){var e=n.useContext(m),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},s=function(t){var e=d(t.components);return n.createElement(m.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},p=n.forwardRef((function(t,e){var a=t.components,l=t.mdxType,r=t.originalType,m=t.parentName,s=o(t,["components","mdxType","originalType","parentName"]),p=d(a),g=l,k=p["".concat(m,".").concat(g)]||p[g]||u[g]||r;return a?n.createElement(k,i(i({ref:e},s),{},{components:a})):n.createElement(k,i({ref:e},s))}));function g(t,e){var a=arguments,l=e&&e.mdxType;if("string"==typeof t||l){var r=a.length,i=new Array(r);i[0]=p;var o={};for(var m in e)hasOwnProperty.call(e,m)&&(o[m]=e[m]);o.originalType=t,o.mdxType="string"==typeof t?t:l,i[1]=o;for(var d=2;d<r;d++)i[d]=a[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},58792:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>m,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var n=a(87462),l=(a(67294),a(3905));const r={},i="Designing SCDs",o={unversionedId:"data-modeling/designing-scd",id:"data-modeling/designing-scd",title:"Designing SCDs",description:"Whereas operational source systems contain only the latest version of master data, the star schema enables time travel queries to reproduce dimension attribute values on past dates when the fact transaction or event actually happened. The star schema data model allows analytical users to query historical data tying metrics to corresponding dimensional attribute values over time. Time travel is possible because dimension tables contain the exact version of the associated attributes at different time ranges. Relative to the metrics data that keeps changing on a daily or even hourly basis, the dimension attributes change less frequently. Therefore, dimensions in a star schema that keeps track of changes over time are referred to as slowly changing dimensions (SCDs).",source:"@site/docs/04-data-modeling/designing-scd.md",sourceDirName:"04-data-modeling",slug:"/data-modeling/designing-scd",permalink:"/docs/data-modeling/designing-scd",draft:!1,tags:[],version:"current",lastUpdatedBy:"sparsh",lastUpdatedAt:1681047270,formattedLastUpdatedAt:"Apr 9, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Designing for incremental loading",permalink:"/docs/data-modeling/designing-incremental-loading"},next:{title:"Dimensional Modeling",permalink:"/docs/data-modeling/dimensional-modeling"}},m={},d=[{value:"Designing SCD1",id:"designing-scd1",level:2},{value:"Designing SCD2",id:"designing-scd2",level:2},{value:"Designing SCD3",id:"designing-scd3",level:2},{value:"Designing SCD4",id:"designing-scd4",level:2},{value:"Designing SCD5, SCD6, and SCD7",id:"designing-scd5-scd6-and-scd7",level:2}],s={toc:d};function u(t){let{components:e,...a}=t;return(0,l.kt)("wrapper",(0,n.Z)({},s,a,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"designing-scds"},"Designing SCDs"),(0,l.kt)("p",null,"Whereas operational source systems contain only the latest version of ",(0,l.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Master_data"},"master data"),", the star schema enables time travel queries to reproduce dimension attribute values on past dates when the fact transaction or event actually happened. The star schema data model allows analytical users to query historical data tying metrics to corresponding dimensional attribute values over time. Time travel is possible because dimension tables contain the exact version of the associated attributes at different time ranges. Relative to the metrics data that keeps changing on a daily or even hourly basis, the dimension attributes change less frequently. Therefore, dimensions in a star schema that keeps track of changes over time are referred to as ",(0,l.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Slowly_changing_dimension"},"slowly changing dimensions")," (SCDs)."),(0,l.kt)("p",null,"SCDs refer to data in dimension tables that changes slowly over time and not at a regular cadence. A common example for SCDs is customer profiles\u2014for example, an email address or the phone number of a customer doesn't change that often, and these are perfect candidates for SCD."),(0,l.kt)("p",null,"Here are some of the main aspects we will need to consider while designing an SCD:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Should we keep track\xa0of the changes? If yes, how much of the history should we maintain?"),(0,l.kt)("li",{parentName:"ul"},"Or, should we just overwrite the changes and ignore the history?")),(0,l.kt)("p",null,"Based on our requirements for maintaining the history, there are about seven ways in which we can accomplish keeping track of changes. They are named SCD1, SCD2, SCD3, and so on, up to SCD7."),(0,l.kt)("p",null,"Among these, SCD1, SCD2, SCD3, SCD4, and SCD6 are the most important ones."),(0,l.kt)("h2",{id:"designing-scd1"},"Designing SCD1"),(0,l.kt)("p",null,"In SCD type 1, the values are overwritten and no history is maintained, so once the data is updated, there is no way to find out what the previous value was. The new queries will always return the most recent value. Here is an example of an SCD1 table:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Customer ID"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"City"),(0,l.kt)("th",{parentName:"tr",align:null},"Email"),(0,l.kt)("th",{parentName:"tr",align:null},"..."))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"New York"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"...")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Customer ID"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"City"),(0,l.kt)("th",{parentName:"tr",align:null},"Email"),(0,l.kt)("th",{parentName:"tr",align:null},"..."))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"New Jersey"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"...")))),(0,l.kt)("p",null,"In this example, the value of the City column is changing from New York to New Jersey. The value just gets overwritten."),(0,l.kt)("h2",{id:"designing-scd2"},"Designing SCD2"),(0,l.kt)("p",null,"In SCD2, we maintain a complete history of changes. Every time there is a change, we add a new row with all the details without deleting the previous values. There are multiple ways in which we can accomplish this. Let's take a look at the most common approaches."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Using a flag")),(0,l.kt)("p",null,"In this approach, we use a flag to indicate if a particular value is active or if it is current. Here is an example of this:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"SurrogateID"),(0,l.kt)("th",{parentName:"tr",align:null},"CustomerID"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"City"),(0,l.kt)("th",{parentName:"tr",align:null},"isActive"),(0,l.kt)("th",{parentName:"tr",align:null},"..."))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"New York"),(0,l.kt)("td",{parentName:"tr",align:null},"True"),(0,l.kt)("td",{parentName:"tr",align:null},"...")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"SurrogateID"),(0,l.kt)("th",{parentName:"tr",align:null},"CustomerID"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"City"),(0,l.kt)("th",{parentName:"tr",align:null},"isActive"),(0,l.kt)("th",{parentName:"tr",align:null},"..."))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"New York"),(0,l.kt)("td",{parentName:"tr",align:null},"False"),(0,l.kt)("td",{parentName:"tr",align:null},"...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"2"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"New Jersey"),(0,l.kt)("td",{parentName:"tr",align:null},"False"),(0,l.kt)("td",{parentName:"tr",align:null},"...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"3"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"Miami"),(0,l.kt)("td",{parentName:"tr",align:null},"True"),(0,l.kt)("td",{parentName:"tr",align:null},"...")))),(0,l.kt)("p",null,"In the second table, every time there is a change, we add a new row and update the isActive column of the previous rows to False. That way, we can easily query the active values by filtering on the isActive=True criteria."),(0,l.kt)("p",null,"NOTE"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Surrogate keys are secondary row identification keys. They are added in all SCD2 cases because the primary identification key will not be unique anymore with newly added rows.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Using version numbers")),(0,l.kt)("p",null,"In this approach, we use version numbers to keep track of changes. The row with the highest version is the most current value. Here is an example of this:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"SurrogateID"),(0,l.kt)("th",{parentName:"tr",align:null},"CustomerID"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"City"),(0,l.kt)("th",{parentName:"tr",align:null},"Version"),(0,l.kt)("th",{parentName:"tr",align:null},"..."))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"New York"),(0,l.kt)("td",{parentName:"tr",align:null},"0"),(0,l.kt)("td",{parentName:"tr",align:null},"...")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"SurrogateID"),(0,l.kt)("th",{parentName:"tr",align:null},"CustomerID"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"City"),(0,l.kt)("th",{parentName:"tr",align:null},"Version"),(0,l.kt)("th",{parentName:"tr",align:null},"..."))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"New York"),(0,l.kt)("td",{parentName:"tr",align:null},"0"),(0,l.kt)("td",{parentName:"tr",align:null},"...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"2"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"New Jersey"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"3"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"Miami"),(0,l.kt)("td",{parentName:"tr",align:null},"2"),(0,l.kt)("td",{parentName:"tr",align:null},"...")))),(0,l.kt)("p",null,"In the previous example, we need to filter on the MAX(Version) column to get the current values."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Using date ranges")),(0,l.kt)("p",null,"In this approach, we use date ranges to show the period a particular record (row) was active, as illustrated in the following example:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"SurrogateID"),(0,l.kt)("th",{parentName:"tr",align:null},"CustomerID"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"City"),(0,l.kt)("th",{parentName:"tr",align:null},"StartDate"),(0,l.kt)("th",{parentName:"tr",align:null},"EndDate"),(0,l.kt)("th",{parentName:"tr",align:null},"..."))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"New York"),(0,l.kt)("td",{parentName:"tr",align:null},"01-Jan-2020"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL"),(0,l.kt)("td",{parentName:"tr",align:null},"...")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"SurrogateID"),(0,l.kt)("th",{parentName:"tr",align:null},"CustomerID"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"City"),(0,l.kt)("th",{parentName:"tr",align:null},"StartDate"),(0,l.kt)("th",{parentName:"tr",align:null},"EndDate"),(0,l.kt)("th",{parentName:"tr",align:null},"..."))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"New York"),(0,l.kt)("td",{parentName:"tr",align:null},"01-Jan-2020"),(0,l.kt)("td",{parentName:"tr",align:null},"25-Mar-2020"),(0,l.kt)("td",{parentName:"tr",align:null},"...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"2"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"New Jersey"),(0,l.kt)("td",{parentName:"tr",align:null},"25-Mar-2020"),(0,l.kt)("td",{parentName:"tr",align:null},"01-Dec-2020"),(0,l.kt)("td",{parentName:"tr",align:null},"...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"3"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"Miami"),(0,l.kt)("td",{parentName:"tr",align:null},"01-Dec-2020"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL"),(0,l.kt)("td",{parentName:"tr",align:null},"...")))),(0,l.kt)("p",null,"In the previous example, every time we change a field, we add a new record to the table. Along with that, we update the EndDate column of the previous record and the StartDate column for the new record with today's date. In order to fetch the current record, we have to filter on the EndDate=NULL criteria, or, instead, we could just fill in a very futuristic date instead of NULL\u2014something such as 31-Dec-2100."),(0,l.kt)("p",null,"As a variation to the date-range approach, we could also add a flag column to easily identify active or current records. The following example shows this approach:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"SurrogateID"),(0,l.kt)("th",{parentName:"tr",align:null},"CustomerID"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"City"),(0,l.kt)("th",{parentName:"tr",align:null},"StartDate"),(0,l.kt)("th",{parentName:"tr",align:null},"EndDate"),(0,l.kt)("th",{parentName:"tr",align:null},"isActive"),(0,l.kt)("th",{parentName:"tr",align:null},"..."))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"New York"),(0,l.kt)("td",{parentName:"tr",align:null},"01-Jan-2020"),(0,l.kt)("td",{parentName:"tr",align:null},"25-Mar-2020"),(0,l.kt)("td",{parentName:"tr",align:null},"False"),(0,l.kt)("td",{parentName:"tr",align:null},"...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"2"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"New Jersey"),(0,l.kt)("td",{parentName:"tr",align:null},"25-Mar-2020"),(0,l.kt)("td",{parentName:"tr",align:null},"01-Dec-2020"),(0,l.kt)("td",{parentName:"tr",align:null},"False"),(0,l.kt)("td",{parentName:"tr",align:null},"...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"3"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"Miami"),(0,l.kt)("td",{parentName:"tr",align:null},"01-Dec-2020"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL"),(0,l.kt)("td",{parentName:"tr",align:null},"True"),(0,l.kt)("td",{parentName:"tr",align:null},"...")))),(0,l.kt)("h2",{id:"designing-scd3"},"Designing SCD3"),(0,l.kt)("p",null,"In SCD3, we maintain only a partial history and not a complete history. Instead of adding additional rows, we add an extra column that stores the previous value, so only one version of historic data will be preserved. As with the SCD2 option, here again, we can choose to add date columns to keep track of modified dates, but we don't need surrogate keys in this case as the identification key of the record doesn't change. Here is an example of this:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"CustomerID"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"City"),(0,l.kt)("th",{parentName:"tr",align:null},"PrevCity"),(0,l.kt)("th",{parentName:"tr",align:null},"..."))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"New York"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL"),(0,l.kt)("td",{parentName:"tr",align:null},"...")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"CustomerID"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"City"),(0,l.kt)("th",{parentName:"tr",align:null},"PrevCity"),(0,l.kt)("th",{parentName:"tr",align:null},"..."))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"New Jersey"),(0,l.kt)("td",{parentName:"tr",align:null},"New York"),(0,l.kt)("td",{parentName:"tr",align:null},"...")))),(0,l.kt)("p",null,"In the previous example, we have added a new column called PrevCity. Every time the value of City changes, we add the previous value to PrevCity and update the City column with the current city."),(0,l.kt)("h2",{id:"designing-scd4"},"Designing SCD4"),(0,l.kt)("p",null,"SCD4 was introduced for dimension attributes that change relatively frequently. In type 4, we split the fast-changing attributes of the dimension table into another smaller dimension table and also reference the new dimension table directly from the fact table."),(0,l.kt)("p",null,"For example, in the following diagram, if we assume that the carpool (also known as High occupancy vehicles) pass needs to be purchased every month, we can move that field to a smaller mini-dimension and reference it directly from the fact table:"),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/218293241-5d41063b-5dc9-45ac-bcf7-77c9fc41532b.jpeg",alt:"B17525_04_009"})),(0,l.kt)("p",null,"We can split the table into a mini DimCarPool dimension, as in the following diagram:"),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/62965911/218293244-d9892da4-f4cf-4010-8188-f040f0d5d784.jpeg",alt:"B17525_04_010"})),(0,l.kt)("p",null,"This sub-division helps in modifying only a smaller amount of data frequently instead of the complete row."),(0,l.kt)("h2",{id:"designing-scd5-scd6-and-scd7"},"Designing SCD5, SCD6, and SCD7"),(0,l.kt)("p",null,"The rest of the SCDs\u2014SCD5, SCD6, and SCD7\u2014are derivatives of the previous four SCDs. Among these derived ones, SCD6 is a relatively important one, so we will be exploring that as part of the next sub-section."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Designing SCD6")),(0,l.kt)("p",null,"Type 6 is a combination of 1, 2, and 3. In this type, along with the addition of new rows, we also update the latest value in all the rows, as illustrated below:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"SurrogateID"),(0,l.kt)("th",{parentName:"tr",align:null},"CustomerID"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"CurrCity"),(0,l.kt)("th",{parentName:"tr",align:null},"PrevCity"),(0,l.kt)("th",{parentName:"tr",align:null},"StartDate"),(0,l.kt)("th",{parentName:"tr",align:null},"EndDate"),(0,l.kt)("th",{parentName:"tr",align:null},"isActive"),(0,l.kt)("th",{parentName:"tr",align:null},"..."))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"Miami"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL"),(0,l.kt)("td",{parentName:"tr",align:null},"01-Jan-2020"),(0,l.kt)("td",{parentName:"tr",align:null},"25-Mar-2020"),(0,l.kt)("td",{parentName:"tr",align:null},"False"),(0,l.kt)("td",{parentName:"tr",align:null},"...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"2"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"Miami"),(0,l.kt)("td",{parentName:"tr",align:null},"New York"),(0,l.kt)("td",{parentName:"tr",align:null},"25-Mar-2020"),(0,l.kt)("td",{parentName:"tr",align:null},"01-Dec-2020"),(0,l.kt)("td",{parentName:"tr",align:null},"False"),(0,l.kt)("td",{parentName:"tr",align:null},"...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"3"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Adam"),(0,l.kt)("td",{parentName:"tr",align:null},"Miami"),(0,l.kt)("td",{parentName:"tr",align:null},"New Jersey"),(0,l.kt)("td",{parentName:"tr",align:null},"01-Dec-2020"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL"),(0,l.kt)("td",{parentName:"tr",align:null},"True"),(0,l.kt)("td",{parentName:"tr",align:null},"...")))),(0,l.kt)("p",null,"In the previous example, you would have noticed that the CurrCity value for all the records belonging to customer Adam has been updated. This is just another benefit of extracting the latest values."),(0,l.kt)("p",null,"That explains SCD type 6. If you are interested in learning about SCDs 5 and 7, you can find more information at the following links:"),(0,l.kt)("p",null,"SCD5: ",(0,l.kt)("a",{parentName:"p",href:"https://www.kimballgroup.com/data-warehouse-business-intelligence-resources/kimball-techniques/dimensional-modeling-techniques/type-5/"},"https://www.kimballgroup.com/data-warehouse-business-intelligence-resources/kimball-techniques/dimensional-modeling-techniques/type-5/")),(0,l.kt)("p",null,"SCD7: ",(0,l.kt)("a",{parentName:"p",href:"https://www.kimballgroup.com/data-warehouse-business-intelligence-resources/kimball-techniques/dimensional-modeling-techniques/type-7"},"https://www.kimballgroup.com/data-warehouse-business-intelligence-resources/kimball-techniques/dimensional-modeling-techniques/type-7")))}u.isMDXComponent=!0}}]);